{"posts":[{"title":"2023.2.2刷题笔记","text":"圣诞节来啦！请用CSS给你的朋友们制作一颗圣诞树吧~这颗圣诞树描述起来是这样的： “topbranch”是圣诞树的上枝叶，该上枝叶仅通过边框属性、左浮动、左外边距即可实现。边框的属性依次是：宽度为100px、是直线、颜色为green（未显示的边框颜色都为透明） “middleBranch”是圣诞树的中枝叶，该上枝叶仅通过边框属性即可实现。边框的属性依次是：宽度为200px、是直线、颜色为green（未显示的边框颜色都为透明） “base”是圣诞树的树干，该树干仅通过左外边距实现居中于中枝叶。树干的宽度、高度分别为70px、200px，颜色为gray。 注意： 上枝叶、树干的居中都是通过左外边距实现的 没有显示的边框，其属性都是透明（属性） 仅通过border属性完成边框的所有属性设置效果如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=utf-8&gt; &lt;style type=&quot;text/css&quot;&gt; .topbranch { width: 0px; height: 0px; /* * TODO: 上枝叶效果 */ float:left; border-bottom: 100px solid green; border-top: 100px solid transparent; border-left:100px solid transparent; border-right:100px solid transparent; margin-left:100px; } .middleBranch { width: 0px; height: 0px; /* * TODO: 中枝叶效果 */ border-bottom:200px solid green; border-top:200px solid transparent; border-left:200px solid transparent; border-right:200px solid transparent; } .base { /* * TODO: 树干效果 */ height:200px; width:70px; background:gray; float:left; margin-left:165px; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;section class=&quot;topbranch&quot;&gt;&lt;/section&gt; &lt;section class=&quot;middleBranch&quot;&gt;&lt;/section&gt; &lt;section class=&quot;base&quot;&gt;&lt;/section&gt; &lt;/body&gt;&lt;/html&gt;","link":"/2023/02/02/2023-2-2%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"},{"title":"Vue2学习汇总","text":"参考网站：介绍 — Vue.js (vuejs.org) 简介Vue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的渐进式框架。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用提供驱动。 Vue实例数据与方法","link":"/2022/10/05/Vue2%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB/"},{"title":"Sass学习汇总","text":"变量Sass 不同于 CSS 的一个特点是它允许使用变量。 可以在 Sass 中声明变量，并为它赋值，就像在 JavaScript 中一样。 在 JavaScript 中，变量是使用 let 和 const 关键字定义的。 在 Sass 中，变量以 $ 开头的，后跟变量名。 这里有几个例子： 12$main-fonts: Arial, sans-serif;$headings-color: green; 并使用变量： 1234h1 { font-family: $main-fonts; color: $headings-color;} 当需要把多个元素设置成相同颜色时，变量就会很有用。 一旦需要更改颜色，只需要改变这个变量的值就好。 嵌套对于一个大型项目，CSS 规则会很复杂。 这时，引入嵌套功能（即在对应的父元素中写子元素的样式）可以有效地简化代码： 1234567891011nav { background-color: red; ul { list-style: none; li { display: inline-block; } }} 函数Mixins在 Sass 中，mixin 是一组 CSS 声明，可以在整个样式表中重复使用。 CSS 的新功能需要一段时间适配后，所有浏览器后才能完全使用。 随着浏览器的不断升级，使用这些 CSS 规则时可能需要添加浏览器前缀。 考虑 box-shadow： 123456div { -webkit-box-shadow: 0px 0px 4px #fff; -moz-box-shadow: 0px 0px 4px #fff; -ms-box-shadow: 0px 0px 4px #fff; box-shadow: 0px 0px 4px #fff;} 对于所有具有 box-shadow 属性的元素重写此规则，或者更改每个值以测试不同的效果，需要花费大量的精力。 Mixins 就像 CSS 的函数。 以下是一个例子： 123456@mixin box-shadow($x, $y, $blur, $c){ -webkit-box-shadow: $x $y $blur $c; -moz-box-shadow: $x $y $blur $c; -ms-box-shadow: $x $y $blur $c; box-shadow: $x $y $blur $c;} 定义以 @mixin 开头，后跟自定义名称。 参数（$x，$y，$blur，以及上例中的 $c ）是可选的。 现在在需要 box-shadow 规则的地方，只需一行 mixin 调用而无需添加所有的浏览器前缀。 mixin 可以通过 @include 指令调用。 123div { @include box-shadow(0px, 0px, 4px, #fff);} 判断@ifSass 中的 @if 指令对于测试特定情况非常有用——它的工作方式与 JavaScript 中的 if 语句类似。 12345@mixin make-bold($bool) { @if $bool == true { font-weight: bold; }} 类似 JavaScript，可以在 Sass 中使用 @else if 和 @else 测试更多条件： 1234567891011121314@mixin text-effect($val) { @if $val == danger { color: red; } @else if $val == alert { color: yellow; } @else if $val == success { color: green; } @else { color: black; }} 记得要在结尾加; 循环@for可以在 Sass 中使用 @for 循环添加样式，它的用法和 JavaScript 中的 for 循环类似。 @for 以两种方式使用：“开始 through 结束” 或 “开始 to 结束”。 主要区别在于“开始 to 结束”不包括结束数字，而“开始 through 结束”包括 结束号码。 这是一个开始 through 结束的示例： 123@for $i from 1 through 12 { .col-#{$i} { width: 100%/12 * $i; }} #{$i} 部分是将变量（i）与文本组合成字符串的语法。 当 Sass 文件转换为 CSS 时，它看起来像这样： 12345678910111213.col-1 { width: 8.33333%;}.col-2 { width: 16.66667%;}....col-12 { width: 100%;} 这是创建网格布局的有效方法。 现在，有了 12 个可用作 CSS class 的列宽选项。 遍历列表@each上一个挑战显示了 @for 指令如何通过起始值和结束值循环一定次数。 Sass 还提供 @each 指令，该指令循环遍历列表或映射中的每个项目。 在每次迭代时，变量将从列表或映射分配给当前值。 123@each $color in blue, red, green { .#{$color}-text {color: $color;}} map 的语法略有不同。 这是一个示例： 12345$colors: (color1: blue, color2: red, color3: green);@each $key, $color in $colors { .#{$color}-text {color: $color;}} 请注意，需要用 $key 变量来引用 map 中的键。 否则，编译后的 CSS 将包含 color1，color2…… 以上两个代码示例都转换为以下 CSS： 1234567891011.blue-text { color: blue;}.red-text { color: red;}.green-text { color: green;} 循环@whileSass 中的 @while 指令与 JavaScript 中的 while 类似。 只要满足条件，它就会一直创建 CSS 代码。 @for 挑战提供了一个创建简单网格系统的示例。 用 @while 也可以实现。 12345$x: 1;@while $x &lt; 13 { .col-#{$x} { width: 100%/12 * $x;} $x: $x + 1;} 首先，定义变量 $x 并将其设置为 1。 接下来，使用 @while 指令，while $x 小于 13 时创建网格系统 。 在设置 width 的 CSS 规则后，$x 增加 1 以避免无限循环。 用 Partials 将样式分成小块Sass 中的 Partials 是包含 CSS 代码段的单独的文件。 这些片段可以导入其它 Sass 文件使用。 可以把类似代码放到模块中，以保持代码结构规整且易于管理。 partials 的名称以下划线（_）字符开头，这样 Sass 就知道它是 CSS 的一小部分，而不会将其转换为 CSS 文件。 此外，Sass 文件以 .scss 文件扩展名结尾。 要将 partial 中的代码放入另一个 Sass 文件中，使用 @import 指令。 例如，如果所有 mixins 都保存在名为 “_mixins.scss” 的 partial 中，并且在 “main.scss” 文件中需要它们，下面是使用方法： 1@import 'mixins' 请注意，import 语句中不需要下划线——Sass 知道它是 partial。 将 partial 导入文件后，可以使用所有变量、mixins 和其它代码。 extendSass 有一个名为 extend 的功能，可以很容易地从一个元素中借用 CSS 规则并在另一个元素上重用它们。 例如，下面的 CSS 规则块设置了 .panel class 的样式。 它有 background-color，height 和 border。 12345.panel{ background-color: red; height: 70px; border: 2px solid green;} 现在需要另一个名为 .big-panel 的面板。 它具有与 .panel 相同的基本属性，但还需要 width 和 font-size。 可以从 .panel 复制并粘贴初始 CSS 规则，但是当添加更多类型的面板时，代码会变得重复。 extend 指令是一种重用为一个元素编写的规则的简单方法，可以为另一个元素重用并添加更多规则： 12345.big-panel{ @extend .panel; width: 150px; font-size: 2em;} 除了新样式之外，.big-panel 将具有与 .panel 相同的属性。","link":"/2022/10/20/Sass%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB/"},{"title":"Html学习汇总","text":"标签段落 p 两个p标签之间，浏览器会自动地在段前段后添加空行 在不产生一个新起点的情况下进行换行：换行符&lt;br/&gt; 列表 ul / ol无序列表1234&lt;ul&gt;&lt;li&gt;Coffee&lt;/li&gt;&lt;li&gt;Milk&lt;/li&gt;&lt;/ul&gt; 有序列表1234&lt;ol&gt; &lt;li&gt;Coffee&lt;/li&gt; &lt;li&gt;Milk&lt;/li&gt; &lt;/ol&gt; 自定义列表123456&lt;dl&gt;&lt;dt&gt;Coffee&lt;/dt&gt;&lt;dd&gt;- black hot drink&lt;/dd&gt;&lt;dt&gt;Milk&lt;/dt&gt;&lt;dd&gt;- white cold drink&lt;/dd&gt;&lt;/dl&gt; 自定义列表不仅仅是一列项目，而是项目及其注释的组合。自定义列表以 标签开始。每个自定义列表项以 开始。每个自定义列表项的定义以 `` 开始。 超链接 ad 属性可用于在一个 HTML 文档中创建书签标记。 提示: 书签是不以任何特殊的方式显示，在 HTML 文档中是不显示的，所以对于读者来说是隐藏的。 在 HTML 文档中插入 ID 1&lt;a id=&quot;tips&quot;&gt;Useful Tips Section&lt;/a&gt; 在 HTML 文档中创建一个链接到”有用的提示部分 (id=”tips”）”： 1&lt;a href=&quot;#tips&quot;&gt;Visit the Useful Tips Section&lt;/a&gt; 或者，从另一个页面创建一个链接到”有用的提示 (id=”tips”）部分”： 1&lt;a href=&quot;//www.w3cschool.cn/html_links.html#tips&quot;&gt; Visit the Useful Tips Section&lt;/a&gt; 表单 formHTML5 表单元素_w3cschool 表格 tableHTML 表格_w3cschool 框架 iframeHTML 表单_w3cschool HTML5 特性简单模板12345678910&lt;!-- 声明使用浏览器使用标准模式（CSS1Compat：标准模式，W3C的标准）解析渲染页面，否则就使用浏览器自己的标准解析（怪异模式） --&gt;&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;文档标题&lt;/title&gt; &lt;/head&gt; &lt;body&gt; 文档内容...... &lt;/body&gt; &lt;/html&gt; 语义化标签一个语义元素能够清楚的描述其意义给浏览器和开发者。 无语义 元素实例: &lt;div&gt; 和&lt;span&gt;- 无需考虑内容. 语义元素实例: &lt;form&gt;, &lt;table&gt;, and &lt;img&gt; - 清楚的定义了它的内容. &lt;header&gt; 文档的头部区域 注意用于定义内容的介绍展示区域. 在页面中你可以使用多个&lt;header&gt; 元素. &lt;nav&gt; 用于定义页面的导航链接部分区域，但是，不是所有的链接都需要包含在&lt;nav&gt;元素中! &lt;section&gt; 定义文档中的节（section、区段）。比如章节、页眉、页脚或文档中的其他部分。 &lt;aside&gt; 标签定义页面主区域内容之外的内容（比如侧边栏）。 &lt;footer&gt; 一个页脚通常包含文档的作者，著作权信息，链接的使用条款，联系信息等 &lt;article&gt; 定义独立的内容 论坛帖子 博客帖子 新闻报道 评论 &lt;figcaption&gt; 标签定义 &lt;figure&gt; 元素的标题. 元素应该被置于 “figure” 元素的第一个或最后一个子元素的位置 &lt;figure&gt; 标签规定独立的流内容（图像、图表、照片、代码等等）。 元素的内容应该与主内容相关，但如果被删除，则不应对文档流产生影响。 多媒体标签HTML5 Video(视频)_w3cschool HTML5 Audio(音频)_w3cschool Canvas 画布HTML5 Canvas_w3cschool ❌ 内联 SVGHTML5 内联 SVG_w3cschool 本地存储localStorage:没有时间限制的数据存储 sessionStorage:针对一个 session 的数据存储 localStorage和sessionStorage的api相同，只是名字不同 保存数据：localStorage.setItem(key,value); 读取数据：localStorage.getItem(key); 删除单个数据：localStorage.removeItem(key); 删除所有数据：localStorage.clear(); 得到某个索引的key：localStorage.key(index); ❌ Web SQLHTML5 Web SQL_w3cschool Web WorkersHTML5 Web Workers_w3cschool web worker 是运行在后台的 JavaScript，不会影响页面的性能，更好的解释是，你可以使用web worker提供的一种简单的方法来为web内容在后台线程中运行脚本，这些线程在执行任务的过程中并不会干扰用户界面！ 应用缓存（Cache Manifest）HTML5 应用程序缓存_w3cschool 如需启用应用程序缓存：&lt;html manifest=&quot;demo.appcache&quot;&gt; 每个指定了 manifest 的页面在用户对其访问时都会被缓存，manifest 文件的建议的文件扩展名是：”.appcache”。 请注意，manifest 文件需要配置正确的 MIME-type，即 “text/cache-manifest”。必须在 web 服务器上进行配置。 Manifest 文件manifest 文件是简单的文本文件，它告知浏览器被缓存的内容（以及不缓存的内容）。 manifest 文件可分为三个部分： CACHE MANIFEST - 在此标题下列出的文件将在首次下载后进行缓存 NETWORK - 在此标题下列出的文件需要与服务器的连接，且不会被缓存 FALLBACK - 在此标题下列出的文件规定当页面无法访问时的回退页面（比如 404 页面） 更新缓存一旦应用被缓存，它就会保持缓存直到发生下列情况： 用户清空浏览器缓存 manifest 文件被修改（参阅下面的提示） 由程序来更新应用缓存 无障碍SSEHTML5 SSE_w3cschool 服务器发送事件（Server-sent Events）是基于 WebSocket 协议的一种服务器向客户端发送事件和数据的单向通讯。 HTML5 服务器发送事件（server-sent event）允许网页获得来自服务器的更新。 Server-Sent 事件指的是网页自动获取来自服务器的更新。 以前也可能做到这一点，前提是网页不得不询问是否有可用的更新。通过服务器发送事件，更新能够自动到达。 例子：Facebook/Twitter 更新、估价更新、新的博文、赛事结果等。 WebSocketHTML5 WebSocket_w3cschool 代码规范HTML5 代码规范_w3cschool","link":"/2022/09/25/html%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB/"},{"title":"Css学习汇总","text":"引入方式行内样式(内联样式)1&lt;h1 style=&quot;color: blue;background-color: yellow;border: 1px solid black;&quot;&gt;Hello World!&lt;/h1&gt; 难以维护 内部样式表1234567891011&lt;style&gt; h1 { color: blue; background-color: yellow; border: 1px solid black; } p { color: red; }&lt;/style&gt; 比外部样式表更低效，在不同站点需要重复添加相同的css 外部样式表1&lt;link rel=&quot;stylesheet&quot; href=&quot;styles/style.css&quot;&gt; 选择器通用选择器（不常用）12/*选择页面上所有元素*/* { margin:0; padding:0;} 标签选择器12/*根据某一标签选择元素*/a{} id选择器12/*为标有特定id的元素指定样式*/#idName{} (class)类选择器1234.className{}/*指定特定元素class*/p.className{} 属性选择器 选择器 描述 [attribute] 用于选取带有指定属性的元素。 [attribute=value] 用于选取带有指定属性和值的元素。 [attribute~=value] 用于选取属性值中包含指定词汇的元素。 [attribute|=value] 用于选取带有以指定值开头的属性值的元素，该值必须是整个单词。 [attribute^=value] 匹配属性值以指定值开头的每个元素。 [attribute$=value] 匹配属性值以指定值结尾的每个元素。 [attribute*=value] 匹配属性值中包含指定值的每个元素。 123456789101112131415/*把包含标题（title）的所有元素变为红色*/*[title] {color:red;}/*选择根据一个元素上的某一标签的属性的存在以选择元素*/a[title]{} /*根据一个又特定值的标签属性是否存在来选择*/a[href=&quot;https://example.com&quot;] { }/*将同时有 href 和 title 属性的 HTML 超链接的文本设置为红色*/a[href][title] {color:red;}/*选择 class 属性中包含 important 的元素*/p[class~=&quot;important&quot;] {color: red;} 派生选择器后代选择器123456789101112/* 如果第二个选择器匹配的元素具有与第一个选择器匹配的祖先（父母，父母的父母，父母的父母的父母等）元素，则它们将被选择。利用后代组合器的选择器称 为后代选择器。*//*两个选择器组合*/selector1 selector2 { /* property declarations */}ul.my-things li { margin: 2em;} 子元素选择器123456789/* &gt; 选择符分隔两个元素时,它只会匹配那些作为第一个元素的直接后代(子元素)的第二元素. 与之相比, 当两个元素由 后代选择器 相连时, 它表示匹配存在 的所有由第一个元素作为祖先元素(但不 一定是父元素)的第二个元素, 无论它在 DOM 中&quot;跳跃&quot; 多少次*//*元素中间有没有空白符都可*/h1 &gt; h2 {color:red;}/*与后代选择器结合*/table.company td &gt; p 相邻元素选择器1234567891011/* 介于两个选择器之间，当第二个元素紧跟在第一个元素之后，并且两个元素都是属于同一个父元素的子元素，则第二个元素将被选中。*//* 图片后面紧跟着的段落将被选中 */img + p { font-weight: bold;}/*语法former_element + target_element { style properties }*//*结合后代选择器，子元素选择器*/html &gt; body table + ul {margin-top:20px;} 伪选择器12345/*伪元素是一个附加至选择器末的关键词，允许你对被选择元素的特定部分修改样式。下例中的 ::first-line 伪元素可改变段落首行文字的样式。*/p::first-line { color: blue; text-transform: uppercase;} 所有css伪元素 伪元素是一个附加至选择器末的关键词，允许你对被选择元素的特定部分修改样式。下例中的 ::first-line 伪元素可改变段落首行文字的样式。 所有 CSS 伪类 CSS 伪类 是添加到选择器的关键字，指定要选择的元素的特殊状态。例如，:hover 可被用于在用户将鼠标悬停在按钮上时改变按钮的颜色。 选择器优先级 类型选择器（例如，h1）和伪元素（例如，::before） 类选择器 (例如，.example)，属性选择器（例如，[type=&quot;radio&quot;]）和伪类（例如，:hover） ID 选择器（例如，#example）。 !important规则当在一个样式声明中使用一个 !important 规则时，此声明将覆盖任何其他声明。虽然，从技术上讲，!important 与优先级无关，但它与最终的结果直接相关。使用 !important 是一个坏习惯，应该尽量避免，因为这破坏了样式表中的固有的级联规则 使得调试找bug变得更加困难了。当两条相互冲突的带有 !important 规则的声明被应用到相同的元素上时，拥有更大优先级的声明将会被采用。 经验规则 一定要优先考虑使用样式规则的优先级来解决问题而不是 !important 只有在需要覆盖全站或外部 CSS 的特定页面中使用 !important 永远不要在你的插件中使用 !important 永远不要在全站范围的 CSS 代码中使用 !important 属性单位 单位 名称 描述 px 像素 像素px是相对于显示器屏幕分辨率而言的 em 相对单位 相对于当前对象内文本的字体尺寸。如当前对行内文本的字体尺寸未被人为设置，则相对于浏览器的默认字体尺寸。 rem 相对单位 相对HTML根元素长度单位，通过它既可以做到只修改根元素就成比例地调整所有字体大小，又可以避免字体大小逐层复合的连锁反应 vw Viewport width 默认1vw=整个视窗宽度的1%，全屏为100vw。 vh Viewport height 默认1vh=整个可视窗口高度的1%，全屏是100vh。 背景 Property 描述 background 简写属性，作用是将背景属性设置在一个声明中。 background-attachment 背景图像是否固定或者随着页面的其余部分滚动。 background-color 设置元素的背景颜色。 background-image 把图像设置为背景。 background-position 设置背景图像的起始位置。 background-repeat 设置背景图像是否及如何重复。 文本 属性 描述 color 设置文本颜色 direction 设置文本方向。 letter-spacing 设置字符间距 line-height 设置行高 text-align 对齐元素中的文本 text-decoration 向文本添加修饰 text-indent 缩进元素中文本的首行 text-shadow 设置文本阴影 text-transform 控制元素中的字母 unicode-bidi 设置或返回文本是否被重写 vertical-align 设置元素的垂直对齐 white-space 设置元素中空白的处理方式 word-spacing 设置字间距 字体 Property 描述 font 在一个声明中设置所有的字体属性 font-family 指定文本的字体系列 font-size 指定文本的字体大小 font-style 指定文本的字体样式 font-variant 以小型大写字体或者正常字体显示文本。 font-weight 指定字体的粗细。 列表 属性 描述 list-style 简写属性。用于把所有用于列表的属性设置于一个声明中 list-style-image 将图像设置为列表项标志。 list-style-position 设置列表中列表项标志的位置。 list-style-type 设置列表项标志的类型。 list-style-type属性指定列表项标记的类型 值 描述 none 无标记。 disc 默认。标记是实心圆。 circle 标记是空心圆。 square 标记是实心方块。 decimal 标记是数字。 decimal-leading-zero 0开头的数字标记。(01, 02, 03, 等。) lower-roman 小写罗马数字(i, ii, iii, iv, v, 等。) upper-roman 大写罗马数字(I, II, III, IV, V, 等。) lower-alpha 小写英文字母The marker is lower-alpha (a, b, c, d, e, 等。) upper-alpha 大写英文字母The marker is upper-alpha (A, B, C, D, E, 等。) lower-greek 小写希腊字母(alpha, beta, gamma, 等。) lower-latin 小写拉丁字母(a, b, c, d, e, 等。) upper-latin 大写拉丁字母(A, B, C, D, E, 等。) hebrew 传统的希伯来编号方式 armenian 传统的亚美尼亚编号方式 georgian 传统的乔治亚编号方式(an, ban, gan, 等。) cjk-ideographic 简单的表意数字 hiragana 标记是：a, i, u, e, o, ka, ki, 等。（日文片假名） katakana 标记是：A, I, U, E, O, KA, KI, 等。（日文片假名） hiragana-iroha 标记是：i, ro, ha, ni, ho, he, to, 等。（日文片假名） katakana-iroha 标记是：I, RO, HA, NI, HO, HE, TO, 等。（日文片假名） list-style-position 属性指定列表项标记（项目符号）的位置 值 描述 inside 列表项目标记放置在文本以内，且环绕文本根据标记对齐。 outside 默认值。保持标记位于文本的左侧。列表项目标记放置在文本以外，且环绕文本不根据标记对齐。 inherit 规定应该从父元素继承 list-style-position 属性的值。 表格(table)C:\\Users\\86152\\Desktop\\笔记\\前端笔记\\css_project\\table.html 属性 描述 border 简写属性。在一条声明中设置所有边框属性。 border-collapse 规定是否应折叠表格边框。 border-spacing 规定相邻单元格之间的边框的距离。 caption-side 规定表格标题的位置。 empty-cells 规定是否在表格中的空白单元格上显示边框和背景。 table-layout 设置用于表格的布局算法。 文档流标准文档流web页面和ps等设计软件有本质的区别，web 网页的制作，是个“流”，从上而下 ，像 “织毛衣”。而设计软件 ，想往哪里画东西，就去哪里画 标准文档流下有以下微观现象 1.空白折叠现象多个空格会被合并成一个空格显示到浏览器页面中。img标签换行写。会发现每张图片之间有间隙，如果在一行内写img标签，就解决了这个问题，但是我们不会这样去写我们的html结构。这种现象称为空白折叠现象。 2.高矮不齐，底边对齐文字还有图片大小不一，都会让我们页面的元素出现高矮不齐的现象，但是在浏览器查看我们的页面总会发现底边对齐 3.自动换行，一行写不满，换行写如果在一行内写文字，文字过多，那么浏览器会自动换行去显示我们的文字 浮动流float 属性定义元素在哪个方向浮动。以往这个属性总应用于图像，使文本围绕在图像周围，不过在 CSS 中，任何元素都可以浮动。浮动元素会生成一个块级框，而不论它本身是何种元素。 如果浮动非替换元素，则要指定一个明确的宽度；否则，它们会尽可能地窄。 注释：假如在一行之上只有极少的空间可供浮动元素，那么这个元素会跳至下一行，这个过程会持续到某一行拥有足够的空间为止。 清除浮动css的浮动是因为子级元素使用了float，导致父级元素撑不开，引发一大堆问题 清除浮动的几种方法 直接给父级元素加高度 加带有clear：both (right,left)的div标签 overflow法:这种是最常用的方法，给父级元素增加一个overflow：hidden元素，可以清除浮动 CSS浮动float详解 - 简书 (jianshu.com) 定位流（position）static 定位HTML 元素的默认值，即没有定位，遵循正常的文档流对象。 静态定位的元素不会受到 top, bottom, left, right影响。 relative 定位相对定位元素的定位是相对其正常位置。 移动相对定位元素，但它原本所占的空间不会改变。 absolute 定位绝对定位的元素的位置相对于最近的已定位()父元素，如果元素没有已定位的父元素，那么它的位置相对于html: absolute 定位使元素的位置与文档流无关，因此不占据空间。 absolute 定位的元素和其他元素重叠。 绝对定位的元素不再存在于正常文档布局流中。相反，它坐在它自己的层独立于一切。这是非常有用的：这意味着我们可以创建不干扰页面上其他元素的位置的隔离的UI功能 。例如，弹出信息框和控制菜单；翻转面板；可以在页面上的任何地方拖放的UI功能…… 如何确定定位点第一种情况：用户只给元素指定了absolute，未指定left/top/right/bottom。此时absolute元素的左上角定位点位置就是该元素正常文档流里的位置。 第二种情况：用户给absolute元素指定了left/right，top/bottom ​ 让absolute元素没有position:static以外的父元素。此时absolute所处的层是铺满全屏的，即铺满body。会根据用户指定位置的在body上进行定位。 ​ 只指定left时，元素的左上角定位点的left值会变成用户指定值。但top值仍旧是该元素在正常文档流中的top值： 和relative相爱相杀 和z-index的关系 减少重绘和回流的开销 CSS绝对定位absolute详解 - 简书 (jianshu.com) fixed定位生成绝对定位的元素， 相对于浏览器窗口进行定位。可以通过设置 “left”, “top”, “right” 以及 “bottom” 属性给目标元素定位。例如：将id = content 的div固定在窗口底部，距离窗口左边距离200px。滚动条上下滚动，div仍然在窗口底部。 fixed与sticky布局 sticky定位它基本上是相对位置和固定位置的混合体，它允许被定位的元素表现得像相对定位一样，直到它滚动到某个阈值点（例如，从视口顶部起10像素）为止，此后它就变得固定了。例如，它可用于使导航栏随页面滚动直到特定点，然后粘贴在页面顶部 fixed与sticky布局 display none 此元素不会被显示。 block 此元素将显示为块级元素，此元素前后会带有换行符。 inline 默认。此元素会被显示为内联元素，元素前后没有换行符。 inline-block 行内块元素。（CSS2.1 新增的值） inherit 规定应该从父元素继承 display 属性的值。 flex弹性布局 内联元素(inline) 内联元素(inline)不会独占一行，相邻的内联元素会排在同一行。其宽度随内容的变化而变化。 内联元素不可以设置宽高 内联元素可以设置margin，padding，但只在水平方向有效。 内联元素之间有空白区域，空白区域的形成是因为&lt;span&gt;之间有回车，在html中，空格、制表符、回车都属于空白符，多个空白符都会视为一个空格，空格的大小由父级&lt;div&gt;的font-size决定。注意：只有内联(内联块)与内联(内联块)之间的空白符才会形成一个空格，文本元素(除空白符)也是属于内联元素。常用解决方法，给&lt;div&gt;设置font-size: 0;，在&lt;span&gt;上把font-size设置回去 常见内联元素12&lt;a&gt;、&lt;span&gt;、&lt;br&gt;、&lt;i&gt;、&lt;em&gt;、&lt;strong&gt;&lt;label&gt;、&lt;q&gt;、&lt;var&gt;、&lt;cite&gt;、&lt;code&gt; 内联块状元素inline-block：简单来说就是将对象呈现为inline对象，但是对象的内容作为block对象呈现（可以设置宽高和margin值）。之后的内联对象会被排列在同一内联。比如我们可以给一个link（a元素）inline-block属性值(display:inline-block)，使其既具有block的宽度高度特性又具有inline的同行特性。 1.和其他元素都在一行上； 2.元素的高度、宽度、行高以及顶和底边距都可设置。 3.它也会有元素间出现空白区域的问题 常见内联块状元素1&lt;img&gt;、&lt;input&gt; 块状元素(block) 块级元素会独占一行，默认情况下宽度自动填满其父元素宽度 (width 默认为 100%) 块级元素可以设置宽高 块级元素可以设置margin，padding display：block，内联元素可使用此属性块状化 常见块状元素123&lt;div&gt;、&lt;p&gt;、&lt;h1&gt;-&lt;h6&gt;、&lt;ol&gt;、&lt;ul&gt;、&lt;dl&gt;、&lt;table&gt;、&lt;address&gt;、&lt;blockquote&gt; 、&lt;form&gt; 盒子模型css的box模型有一个外部显示类型（display：block），来决定盒子是块级还是内联。 同样盒模型还有内部显示类型，它决定了盒子内部元素是如何布局的。默认情况下是按照 正常文档流 布局，也意味着它们和其他块元素以及内联元素一样(如上所述). 但是，我们可以通过使用类似 flex 的 display 属性值来更改内部显示类型。 如果设置 display: flex，在一个元素上，外部显示类型是 block，但是内部显示类型修改为 flex。 该盒子的所有直接子元素都会成为flex元素，会根据 弹性盒子（Flexbox ）规则进行布局，稍后您将了解这些规则。 Content box: 这个区域是用来显示内容，大小可以通过设置 width 和 height. Padding box: 包围在内容区域外部的空白区域； 大小通过 padding 相关属性设置。 Border box: 边框盒包裹内容和内边距。大小通过 border 相关属性设置。 Margin box: 这是最外面的区域，是盒子和其他元素之间的空白区域。大小通过 margin 相关属性设置。 外边距折叠:有两个外边距相接的元素，这些外边距将合并为一个外边距，即最大的单个外边距的大小。 内联元素：由于忽略了高度和宽度，但外边距，内边距与边框都会生效，他们不会改变其他内容与内联盒子的关系因此会出现以下情况 层叠规则层叠上下文网页上的元素其实是三维的，类似于高中学的左手坐标系，Z轴就是垂直于屏幕。层叠上下文跟“块状格式化上下文”（BFC）类似，只要元素拥有某些特定的css属性，就会表现出层叠上下文的特点。 前提是重叠在一起，就会按照上图的规则呈现。 层叠准则 (1) 谁大谁上：如生效的z-index属性值，大的就覆盖小的。 (2)后来居上：当元素的层叠顺序一致的时候，比较后面的元素就会覆盖前面的元素。 普通元素可以添加overflow：hidden；使他成为BFC元素。而层叠上下文也可以添加某些css属性变成的。（） 根层叠上下文指的是页面根元素。 对于position为relative/absolute/fixed的元素，当他的z-index不是auto时，就会创建层叠上下文。 css3新属性 元素为flex布局元素，同时z-index值不是auto。 元素的opacity不是1 元素的transform值不是none 元素的filter不是none 元素的mix-blend-mode不止normal 元素的isolation不是isolate 元素的will-change属性值为上面2~6的任意一个 元素的-webkit-overflow-scrolling设为touch 样式表层叠当应用两条同级别的规则到一个元素的时候，写在后面的就是实际使用的规则。 1234567h1 { color: red; }/*第二个样式生效*/h1 { color: blue; } css层叠规则有三个因素需要考虑，根据重要性排序如下，前面的更重要： 重要程度 我们已经看到了顺序对于层叠的重要性。如果你有超过一条规则，而且都是相同的权重，那么最后面的规则会应用。可以理解为后面的规则覆盖前面的规则，直到最后一个开始设置样式。 优先级 浏览器计算优先级： 一个选择器的优先级可以说是由四个部分相加 (分量)，可以认为是个十百千 — 四位数的四个位数： 千位： 如果声明在 style 的属性（内联样式）则该位得一分。这样的声明没有选择器，所以它得分总是1000。 百位： 选择器中包含ID选择器则该位得一分。 十位： 选择器中包含类选择器、属性选择器或者伪类则该位得一分。 个位：选择器中包含元素、伪元素选择器则该位得一分。 警告: 在进行计算时不允许进行进位，例如，20 个类选择器仅仅意味着 20 个十位，而不能视为 两个百位，也就是说，无论多少个类选择器的权重叠加，都不会超过一个 ID 选择器。 资源顺序 当应用两条同级别的规则到一个元素的时候，写在后面的就是实际使用的规则。 1、找出所有相关的规则，这些规则都包含与一个给定元素匹配的选择器。 2、按权重（!important）和来源对应用到给定元素的所有声明进行排序。 3、按特殊性对应用到给定元素的所有声明进行排序，有较高特殊性的元素权重要大于有较低特殊性的元素，0特殊性比无特殊性要强（继承）。 4、按出现顺序对应用到给定元素的所有声明进行排序，后面出现的声明权重要大于前面出现的声明，即后定义的样式会覆盖前面定义的样式。（适用于特殊性一样的时候） 优先级浏览器是根据优先级来决定当多个规则有不同选择器对应相同的元素的时候需要使用哪个规则。它基本上是一个衡量选择器具体选择哪些区域的尺度： 一个元素选择器不是很具体 — 会选择页面上该类型的所有元素 — 所以它的优先级就会低一些。 一个类选择器稍微具体点 — 它会选择该页面中有特定 class 属性值的元素 — 所以它的优先级就要高一点。 继承CSS 为控制继承提供了四个特殊的通用属性值。每个css属性都接收这些值。 inherit 设置该属性会使子元素属性和父元素相同。实际上，就是 “开启继承”. initial 设置属性值和浏览器默认样式相同。如果浏览器默认样式中未设置且该属性是自然继承的，那么会设置为 inherit 。 unset 将属性重置为自然值，也就是如果属性是自然继承那么就是 inherit，否则和 initial一样 注: 还有一个新的属性, revert (en-US)， 只有很少的浏览器支持。 BFC 和 IFC 机制FC：格式化上下文。定义的是页面中的一块渲染区域，并且有一套渲染规则。它决定了其子元素将如何定位，以及和其他元素的关系和相互作用。 布局规则IFC布局规则在行内格式化上下文中，box一个接一个地水平排列，起点是包含块的顶部。 水平方向上的margin border padding在框之间得到保留 在垂直方向上可以以不同的方式对齐：顶部或底部对齐，或者根据文字的基线对齐 BFC布局规则 内部的Box会在垂直方向，一个接一个地放置 Box垂直方向上的距离由margin决定，同属一个BFC的两个相邻Box的margin会发生重叠 每个元素的左外边缘(margin-left)，与包含块的左边(contain box left)相接触(对于从左到右的格式化)。即使存在浮动也是如此，除非这个元素自己形成一个新的BFC BFC的区域不会与float box重叠 BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素 计算BFC的高度时，浮动元素也参与计算 BCF元素 根元素或者其它包含它的元素 浮动元素(float不是none) 绝对定位的元素（position为absolute或fixed） 非块级元素具有display:inline-block， table-cell，table-caption，flex，inline-flex 块级元素具有overflow，且值不是visible 作用 清除浮动：当父盒子div未设置高度，子盒子都设置浮动，则父元素会出现高度塌陷的情况。解决方案：给父元素添加overflow:hidden，使其形成BFC，计算高度时会计算float元素的高度，达到清除浮动影响的效果。 布局：自适应两栏布局 防止垂直margin合并（外边距折叠） CSS3CSS3 教程_w3cschool 选择器盒模型背景和边框边框 border-radius box-shadow:10px 10px 5px #888888;：盒阴影 border-image（需要注意的是：该属性不支持ie浏览器） 背景 background-image:url(img_flwr.gif), url(paper.gif) 可放置两个图像 background-size:80px 60px background-origin:content-box content-box, padding-box,和 border-box区域内可以放置背景图像。 background-clip：content-box 背景剪裁属性是从指定位置开始绘制 渐变CSS3 渐变_w3cschool 线性渐变（Linear Gradients）- 向下/向上/向左/向右/对角方向 从上到下（默认情况下） 1234567background: linear-gradient(direction, color-stop1, color-stop2, ...); #grad { background: -webkit-linear-gradient(red, blue); /* Safari 5.1 - 6.0 */ background: -o-linear-gradient(red, blue); /* Opera 11.1 - 12.0 */ background: -moz-linear-gradient(red, blue); /* Firefox 3.6 - 15 */ background: linear-gradient(red, blue); /* 标准的语法 */} 从左到右 123456#grad { background: -webkit-linear-gradient(left, red , blue); /* Safari 5.1 - 6.0 */ background: -o-linear-gradient(right, red, blue); /* Opera 11.1 - 12.0 */ background: -moz-linear-gradient(right, red, blue); /* Firefox 3.6 - 15 */ background: linear-gradient(to right, red , blue); /* 标准的语法 */} 对角 123456#grad { background: -webkit-linear-gradient(left top, red , blue); /* Safari 5.1 - 6.0 */ background: -o-linear-gradient(bottom right, red, blue); /* Opera 11.1 - 12.0 */ background: -moz-linear-gradient(bottom right, red, blue); /* Firefox 3.6 - 15 */ background: linear-gradient(to bottom right, red , blue); /* 标准的语法 */} 径向渐变（Radial Gradients）- 由它们的中心定义 文字特效CSS3 文本效果_w3cschool CSS3 字体_w3cschool(@font-face规则，使用在线字体) text-shadow: 5px 5px 5px #FF0000 文本阴影 box-shadow:10px 10px 5px grey ; 盒子阴影 text-overflow：clip/ellipsis如何显示溢出内容（直接切割；省略号） 1234567div.test{ white-space:nowrap; width:12em; overflow:hidden; border:1px solid #000000;} word-wrap:break-word/normal文本的换行规则 word-break 属性 描述 CSS hanging-punctuation 规定标点字符是否位于线框之外。 3 punctuation-trim 规定是否对标点字符进行修剪。 3 text-align-last 设置如何对齐最后一行或紧挨着强制换行符之前的行。 3 text-emphasis 向元素的文本应用重点标记以及重点标记的前景色。 3 text-justify 规定当 text-align 设置为 “justify” 时所使用的对齐方法。 3 text-outline 规定文本的轮廓。 3 text-overflow 规定当文本溢出包含元素时发生的事情。 3 text-shadow 向文本添加阴影。 3 text-wrap 规定文本的换行规则。 3 word-break 规定非中日韩文本的换行规则。 3 word-wrap 允许对长的不可分割的单词进行分割并换行到下一行。 3 2D/3D转换2D转换 translate() 根据左(X轴)和顶部(Y轴)位置给定的参数，从当前元素位置移动。 123456789/* 3种写法 是从左边元素移动50个像素，并从顶部移动100像素。*/div{transform: translate(50px,100px);-ms-transform: translate(50px,100px); /* IE 9 */-webkit-transform: translate(50px,100px); /* Safari and Chrome */} rotate() 在一个给定度数顺时针旋转的元素。负值是允许的，这样是元素逆时针旋转。 1234567/*（30deg）元素顺时针旋转30度。*/div{transform: rotate(30deg);-ms-transform: rotate(30deg); /* IE 9 */-webkit-transform: rotate(30deg); /* Safari and Chrome */} scale() 该元素增加或减少的大小，取决于宽度（X轴）和高度（Y轴）的参数： 1234567/*转变宽度为原来的大小的2倍，和其原始大小4倍的高度*/div{transform: scale(2,4);-ms-transform: scale(2,4); /* IE 9 */-webkit-transform: scale(2,4); /* Safari and Chrome /} skew() 包含两个参数值，分别表示X轴和Y轴倾斜的角度，如果第二个参数为空，则默认为0，参数为负表示向相反方向倾斜。 skewX( );表示只在X轴(水平方向)倾斜。 skewY( );表示只在Y轴(垂直方向)倾斜。 1234567/*元素在X轴和Y轴上倾斜30度和20度。*/div{transform: skew(30deg,20deg);-ms-transform: skew(30deg,20deg); /* IE 9 */-webkit-transform: skew(30deg,20deg); /* Safari and Chrome /} matrix() matrix()方法和2D变换方法合并成一个。 matrix 方法有六个参数，包含旋转，缩放，移动（平移）和倾斜功能。 1234567/*利用matrix()方法旋转div元素30°*/div{transform:matrix(0.866,0.5,-0.5,0.866,0,0);-ms-transform:matrix(0.866,0.5,-0.5,0.866,0,0); /* IE 9 */-webkit-transform:matrix(0.866,0.5,-0.5,0.866,0,0); /* Safari and Chrome */} 动画过渡CSS3 过渡_w3cschool CSS3 过渡是元素从一种样式逐渐改变为另一种的效果。 要实现这一点，必须规定两项内容： 指定要添加效果的CSS属性 1234div:hover{width:300px;} 指定效果的持续时间。 1234567891011121314/* 应用于宽度属性的过渡效果，时长为 2 秒： 如果未指定的期限，transition将没有任何效果，因为默认值是0。*/div{transition: width 2s;-webkit-transition: width 2s; /* Safari */} div{transition: width 2s, height 2s, transform 2s;-webkit-transition: width 2s, height 2s, -webkit-transform 2s;} 属性 描述 CSS transition 简写属性，用于在一个属性中设置四个过渡属性。 3 transition-property 规定应用过渡的 CSS 属性的名称。 3 transition-duration 定义过渡效果花费的时间。默认是 0。 3 transition-timing-function 规定过渡效果的时间曲线。默认是 “ease”。 3 transition-delay 规定过渡效果何时开始。默认是 0。 3 动画CSS3 动画_w3cschool 多列布局 column-count 123456789/* 划分成三列的div元素的文本*/div{-moz-column-count:3; /* Firefox */-webkit-column-count:3; /* Safari and Chrome */column-count:3;} column-gap 123456789/* 指定列之间40个像素差距*/div{-moz-column-gap:40px; /* Firefox */-webkit-column-gap:40px; /* Safari and Chrome */column-gap:40px;} column-rule 123456789/* 指定列之间的宽度，样式和颜色的规则*/div{-moz-column-rule:3px outset #ff00ff; /* Firefox */-webkit-column-rule:3px outset #ff00ff; /* Safari and Chrome */column-rule:3px outset #f00ff;} column-rule-color column-rule-style column-rule-width column-width 属性 说明 CSS column-count 指定元素应分为的列数 3 column-fill 指定如何填充列 3 column-gap 指定列之间差距 3 column-rule 一个用于设置所有列规则的简写属性 3 column-rule-color 指定的列之间颜色规则 3 column-rule-style 指定的列之间的样式规则 3 column-rule-width 指定的列之间的宽度规则 3 column-span 指定一个元素应该横跨多少列 3 column-width 指定列的宽度 3 columns 缩写属性设置列宽和列数 用户界面 resize box-sizing outline-offset","link":"/2022/10/10/css%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB/"},{"title":"JavaScript学习汇总","text":"变量值数据类型 字符串 String​ 字符串是文本的一部分。当你给一个变量赋值为字符串时，你需要用单引号或者双引号把值给包起来，否则 JavaScript 将会把这个字符串值理解成别的变量名。 数组 Number​ 你可以在变量中存储数字，不论这些数字是像 30（也叫整数）这样，或者像 2.456 这样的小数（也叫做浮点数）。与其他编程语言不同，在 JavaScript 中你不需要声明一个变量的类型。当你给一个变量数字赋值时，不需要用引号括起来。 最大值为2^53，如果超出最大值，会进行取整操作 布尔 BooleanBoolean 的值有 2 种：true 或 false。它们通常被用于在适当的代码之后，测试条件是否成立。 数值类型环境中会被当作 0 来对待 布尔类型环境中会被当作false 12var n = null;console.log(n * 32); // 在控制台中会显示 0 空值 Null 未定义 Undefined 使用 undefined 来判断一个变量是否已赋值 在布尔类型环境中会被当作false 数值类型环境中会被转换为NaN 变量提升 JavaScript 变量感觉上是被“提升”或移到了函数或语句的最前面。但是，提升后的变量将返回 undefined 值。因此在使用或引用某个变量之后进行声明和初始化操作，这个被提升的变量仍将返回 undefined 值。 在 ECMAScript 6 中，let和const同样会被提升变量到代码块的顶部但是不会被赋予初始值。在变量声明之前引用这个变量，将抛出引用错误（ReferenceError）。这个变量将从代码块一开始的时候就处在一个“暂时性死区”，直到这个变量被声明为止。 12console.log(x === undefined); // truevar x = 3; 12var a;a + 2; // 计算为 NaN Symbol 引用数据类型 对象 Object​ 在编程中，对象是现实生活中的模型的一种代码结构。您可以有一个简单的对象，代表一个停车场，并包含有关其宽度和长度的信息，或者您可以有一个代表一个人的对象，并包含有关他们的名字，身高，体重，他们说什么语言，如何说 你好，他们，等等。 1let dog = { name : 'Spot', breed : 'Dalmatian' }; 数组 Array数组是一个单个对象，其中包含很多值，方括号括起来，并用逗号分隔 12let myNameArray = ['Chris', 'Bob', 'Jim'];let myNumberArray = [10,15,40]; 常见方法(75条消息) 详解split()使用方法_陈小谷谷的博客-CSDN博客_split 123let myData = 'Manchester,London,Liverpool,Birmingham,Leeds,Carlisle';let myArray = myData.split(',');//根据每个逗号分隔 函数 Function12345function functionname(var1,var2){ // 执行代码 return x} var与let的区别var可以多次声明相同名称的变量 使用 var 关键字声明变量时，它是全局声明的，如果在函数内部声明则是局部声明的。 let 关键字的行为类似，但有一些额外的功能。 在代码块、语句或表达式中使用 let 关键字声明变量时，其作用域仅限于该代码块、语句或表达式。 123456789101112var numArray = [];for (var i = 0; i &lt; 3; i++) { numArray.push(i);}console.log(numArray);//[0, 1, 2]console.log(i);//3//for (let i = 0; i &lt; 3; i++) { numArray.push(i);}console.log(numArray);//[0, 1, 2]console.lg(i);//未被定义 12var myName = 'Chris';var myName = 'Bob'; let不能多次声明相同名称的变量 12let myName = 'Chris';let myName = 'Bob'; const默认情况下，一些开发人员更喜欢使用 const 分配所有变量，除非他们知道需要重新分配值。 只有在这种情况下，他们才使用 let。 但是，重要的是要了解使用 const 分配给变量的对象（包括数组和函数）仍然是可变的。 使用 const 声明只能防止变量标识符的重新分配。 1234const s = [5, 6, 7];s = [1, 2, 3];//s = [1, 2, 3] 将导致错误。s[2] = 45;console.log(s);//console.log 将显示值 [5, 6, 45]。 const 声明并不会真的保护数据不被改变。 为了确保数据不被改变，JavaScript 提供了一个函数 Object.freeze。 任何更改对象的尝试都将被拒绝，如果脚本在严格模式下运行，将抛出错误。 12345678let obj = { name:&quot;FreeCodeCamp&quot;, review:&quot;Awesome&quot;};Object.freeze(obj);obj.review = &quot;bad&quot;;//错误obj.newProp = &quot;Test&quot;;//错误console.log(obj); 命名规则 你不应当使用规则之外的其他字符，因为它们可能引发错误，或对国际用户来说难以理解。 变量名不要以下划线开头—— 以下划线开头的被某些 JavaScript 设计为特殊的含义，因此可能让人迷惑。 变量名不要以数字开头。这种行为是不被允许的，并且将引发一个错误。 一个可靠的命名约定叫做 “小写驼峰命名法”，用来将多个单词组在一起，小写整个命名的第一个字母然后大写剩下单词的首字符。我们已经在文章中使用了这种命名方法。（myName） 让变量名直观，它们描述了所包含的数据。不要只使用单一的字母/数字，或者长句。 变量名大小写敏感——因此myage与myAge是 2 个不同的变量。 最后也是最重要的一点—— 你应当避免使用 JavaScript 的保留字给变量命名。保留字，即是组成 JavaScript 的实际语法的单词！因此诸如 var, function, let和 for等，都不能被作为变量名使用。浏览器将把它们识别为不同的代码项，因此你将得到错误。 函数apply(90条消息) Js apply方法详解,及其apply()方法的妙用_lixiaotao_1的博客-CSDN博客_apply的参数 劫持另外一个对象的方法，继承另外一个对象的属性 如果 apply() 方法的第一个参数不是对象，则它将成为被调用函数的所有者（对象）。在“非严格”模式下，它成为全局对象。 123456789101112131415161718//Function.apply(obj,args)var person = { fullName: function(city, country) { return this.firstName + &quot; &quot; + this.lastName + &quot;,&quot; + city + &quot;,&quot; + country; }}var person1 = { firstName:&quot;Bill&quot;, lastName: &quot;Gates&quot;}//person使用apply劫持了person1的属性，替代了person中this对象person.fullName.call(person1, [&quot;Oslo&quot;, &quot;Norway&quot;]); // 将返回 &quot;Bill Gates,Seatle,USA&quot;person.fullName.call(person1, &quot;Oslo&quot;, &quot;Norway&quot;); // 将返回 &quot;Bill Gates,Seatle,USA&quot;//求数组最大值var array = [1, 2, 3];var max = Math.max.apply(null, array);console.log(max);//3 callcall 方法的语法和作用与 apply() 方法类似，只有一个区别，就是 call() 方法接受的是一个参数列表，而 apply() 方法接受的是一个包含多个参数的 **数组**。 123456789101112//function.call(thisArg, arg1, arg2, ...);var person = { fullName: function(city, country) { return this.firstName + &quot; &quot; + this.lastName + &quot;,&quot; + city + &quot;,&quot; + country; }}var person1 = { firstName:&quot;Bill&quot;, lastName: &quot;Gates&quot;}person.fullName.call(person1, &quot;Seattle&quot;, &quot;USA&quot;); 闭包彻底理解js闭包 - 知乎 (zhihu.com)（有一道面试题） 闭包 - JavaScript | MDN (mozilla.org) 有权访问另一个函数作用域中的变量的函数；一般情况就是在一个函数中包含另一个函数。 闭包的实现原理，其实是利用了作用域链的特性，我们都知道作用域链就是在当前执行环境下访问某个变量时，如果不存在就一直向外层寻找，最终寻找到最外层也就是全局作用域，这样就形成了一个链条。 作用1：隐藏变量，避免全局污染 作用2：可以读取函数内部的变量 函数创建和函数执行不在同一个作用域下就会形成闭包。 闭包是指那些能够访问自由变量的函数（自由变量：是指在函数中使用的变量即不是函数参数arguments也不是函数内部声明的变量，那这个变量就是自由变量。） 闭包是指有权访问另外一个函数作用域中的变量的函 12345678910111213141516171819202122232425262728293031323334//1、通过全局变量，可以实现，但会污染其他程序var a = 10;function Add(){ a++; console.log(a);}Add();Add();Add();//2、定义一个局部变量，不污染全局，但是实现不了递增var a = 10;function Add2(){ var a = 10; a++; console.log(a);}Add2();Add2();Add2();console.log(a);//3、通过闭包，可以是函数内部局部变量递增，不会影响全部变量var a = 10;function Add3(){ var a = 10; return function(){ a++; return a; };};var cc = Add3();console.log(cc());console.log(cc());console.log(cc());console.log(a); callback回调函数可以将一个函数当作另一个函数的形参来传递。格式如下： 123function A (形参1, 形参2, 函数B) { do something;} 其实你可以先声明一个function 函数B ()这样子的，又可以在调用的时候才去实现这个方法。 12345function A (形参1, 形参2, 函数B) { do something;}A(传入形参1, 传入形参2, 函数B() { 这里是函数B的实现方法体}) 1234567891011121314// 全局变量const s = [23, 65, 98, 5];Array.prototype.myMap = function(callback) { const newArray = []; // 只修改这一行下面的代码 this.forEach(a =&gt; newArray.push(callback(a))); // 只修改这一行上面的代码 return newArray;};const new_s = s.myMap(function(item) { return item * 2;}); 作用回调函数是NodeJs中异步编程很重要的一个知识。例如，我们可以一边读取文件，一边执行其他命令，在文件读取完成后，我们将文件内容作为回调函数的参数返回。这样在执行代码时就没有阻塞或等待文件 I/O 操作。这就大大提高了 Node.js 的性能，可以处理大量的并发请求。 举例123456789101112131415161718192021function add (x, y) { // 设置1秒后出计算结果 console.log('开始运算') setTimeout (function () { // 保存计算结果 console.log('保存计算结果') var result = x + y return result }, 1000) console.log('结束运算')}// 打印返回值结果console.log('计算结果为：'+add(1, 2))//运行结果/*开始运算结束运算计算结果为undefined保存计算结果*/ undefined ？为什么会是这个结果？ 从执行顺序上来看我们就可以得出结论， 打印返回值结果 这一步并没有等待到 setTimeout 里面相加这步运行结束就已经打印结果了 ，所以返回结果为undefined。 我们要做的就是得到setTimeout里面的返回值。 我们来用callback函数改写一下上面的案例 123456789101112131415161718192021222324function add (x, y, callback) { // 设置1秒后出计算结果 console.log('开始运算') setTimeout (function () { // 保存计算结果 console.log('保存计算结果') var result = x + y callback(result) }, 1000) console.log('结束运算')}add(1, 2, function (result) { // 这是callback函数实现体 console.log('计算结果为：'+result)})//运算结果/*开始运算结束运算保存计算结果计算结果为：3*/ 这个函数的执行流程就是：传入x, y -&gt; add跳过等待 -&gt; add执行结束 -&gt;setTimeout开始计算结果 -&gt; 将计算结果当作callback函数的参数 -&gt; callback函数实现体。 作用就是将异步的计算结果当作另一个函数的形参转发出去了。相当于你写多一个方法来保存这个计算结果。 创建新对象使用对象初始化器123456var obj = { property_1: value_1, // property_# 可以是一个标识符... 2: value_2, // 或一个数字... [&quot;property&quot; +3]: value_3, // 或一个可计算的 key 名... // ..., &quot;property n&quot;: value_n }; // 或一个字符串 下面的语句只有当 cond 表达式的值为 true 时创建对象并将其赋给变量 x。 1if (cond) var x = {hi: &quot;there&quot;}; 下例创建了有三个属性的 myHonda 对象。注意它的 engine 属性也是一个拥有自己属性的对象。 1var myHonda = {color: &quot;red&quot;, wheels: 4, engine: {cylinders: 4, size: 2.2}}; 使用构造函数new123456function Car(make, model, year) { this.make = make; this.model = model; this.year = year;}var mycar = new Car(&quot;Eagle&quot;, &quot;Talon TSi&quot;, 1993); 首先创建一个空对象 设置原型，将对象的_proto_纸箱构造函数的protype对象 让函数的this指向这个对象，执行构造函数的代码（为这个新对象添加属性） 判断函数的返回类型，如果是值类型，返回创建的对象。如果是引用型对象，则返回这个引用类型的对象 使用Object.create方法12345678910111213141516// Animal properties and method encapsulationvar Animal = { type: &quot;Invertebrates&quot;, // 属性默认值 displayType : function() { // 用于显示 type 属性的方法 console.log(this.type); }}// 创建一种新的动物——animal1var animal1 = Object.create(Animal);animal1.displayType(); // Output:Invertebrates// 创建一种新的动物——Fishesvar fish = Object.create(Animal);fish.type = &quot;Fishes&quot;;fish.displayType(); // Output:Fishes Object.create(Obj)的内部，并没有去调用Obj构造函数，而是调用了创建新对象的构造函数，因此Obj上的属性不会继承到Object.create创建的实例中 Object.create(Obj)会凭空创建一个“新”对象并把新对象内部的[[Prototype]]关联到你指定的对象 继承所有的 JavaScript 对象至少继承于一个对象。被继承的对象被称作原型，并且继承的属性可通过构造函数的 prototype 对象找到。 在 JavaScript 1.0 中，你可以通过名称或序号访问一个属性。但是在 JavaScript 1.1 及之后版本中，如果你最初使用名称定义了一个属性，则你必须通过名称来访问它；而如果你最初使用序号来定义一个属性，则你必须通过索引来访问它。 这个限制发生在你通过构造函数创建一个对象和它的属性（就象我们之前通过 Car 对象类型所做的那样）并且显式地定义了单独的属性（如 myCar.color = “red”）之时。如果你最初使用索引定义了一个对象属性，例如 myCar[5] = &quot;25&quot;，则你只可能通过 myCar[5] 引用它。 你可以通过 prototype 属性为之前定义的对象类型增加属性。这为该类型的所有对象，而不是仅仅一个对象增加了一个属性。下面的代码为所有类型为 car 的对象增加了 color 属性，然后为对象 car1 的 color 属性赋值： 12Car.prototype.color = null;car1.color = &quot;black&quot;; 通过this引用对象JavaScript 有一个特殊的关键字 this，它可以在方法中使用以指代当前对象。 12&lt;input type=&quot;text&quot; name=&quot;age&quot; size=&quot;3&quot; onChange=&quot;validate(this, 18, 99)&quot;&gt; 当与 form 属性一起使用时，this 可以指代当前对象的父窗体。在下面的例子中，窗体 myForm 包含一个 Text 对象和一个按钮，当用户点击按键，Text 对象的值被设为窗体的名称。按钮的 onclick 事件处理器使用 this.form 以指代其父窗体，即 myForm。 123456&lt;form name=&quot;myForm&quot;&gt;&lt;p&gt;&lt;label&gt;Form name:&lt;input type=&quot;text&quot; name=&quot;text1&quot; value=&quot;Beluga&quot;&gt;&lt;/label&gt;&lt;p&gt;&lt;input name=&quot;button1&quot; type=&quot;button&quot; value=&quot;Show Form Name&quot; onclick=&quot;this.form.text1.value = this.form.name&quot;&gt;&lt;/p&gt;&lt;/form&gt; 定义getters与setters一个 getter 是一个获取某个特定属性的值的方法。一个 setter 是一个设定某个属性的值的方法。你可以为预定义的或用户定义的对象定义 getter 和 setter 以支持新增的属性。定义 getter 和 setter 的语法采用对象字面量语法。 123456789101112131415161718192021//使用使用 使用对象初始化器 定义var o = { a: 7, get b() { return this.a + 1; }, set c(x) { this.a = x / 2 }};//使用 getter 和 setter 添加方法添加到任何对象var o = { a:0 }Object.defineProperties(o, { &quot;b&quot;: { get: function () { return this.a + 1; } }, &quot;c&quot;: { set: function (x) { this.a = x / 2; } }});console.log(o.a); // 7console.log(o.b); // 8o.c = 50;console.log(o.a); // 25 下面这个例子展示使用 getter 和 setter 方法扩展 Date原型，为预定义好的 Date 类添加一个 year 的属性。定义属性 year 的 getter 和 setter 方法用到了 Date 类中已存在的 getFullYear 和 setFullYear 方法。 定义属性 year 的 getter 和 setter： 12345var d = Date.prototype;Object.defineProperty(d, &quot;year&quot;, { get: function() { return this.getFullYear() }, set: function(y) { this.setFullYear(y) }}); 删除属性你可以用 delete 操作符删除一个不是继承而来的属性。下面的例子说明如何删除一个属性： 12345678//Creates a new object, myobj, with two properties, a and b.var myobj = new Object;myobj.a = 5;myobj.b = 12;//Removes the a property, leaving myobj with only the b property.delete myobj.a; 如果一个全局变量不是用 var 关键字声明的话，你也可以用 delete 删除它： 12g = 17;delete g; 比较对象在 JavaScript 中 objects 是一种引用类型。两个独立声明的对象永远也不会相等，即使他们有相同的属性，只有在比较一个对象和这个对象的引用时，才会返回 true. 123456// 两个变量，两个具有同样的属性、但不相同的对象var fruit = {name: &quot;apple&quot;};var fruitbear = {name: &quot;apple&quot;};fruit == fruitbear // return falsefruit === fruitbear // return false 验证对象的构造函数凡是通过构造函数创建出的新对象，这个对象都叫做这个构造函数的 实例。 JavaScript 提供了一种很简便的方法来验证这个事实，那就是通过 instanceof 操作符。 instanceof 允许你将对象与构造函数之间进行比较，根据对象是否由这个构造函数创建的返回 true 或者 false。 以下是一个示例： 123456789let Bird = function(name, color) { this.name = name; this.color = color; this.numLegs = 2;}let crow = new Bird(&quot;Alexis&quot;, &quot;black&quot;);//instanceof 方法会返回 true.crow instanceof Bird; 自身属性与prototype自身属性和 prototype 属性。 自身属性是直接在对象上定义的。 而原型属性在 prototype 上定义。 1234567function Bird(name) { this.name = name; //own property}Bird.prototype.numLegs = 2; // prototype propertylet duck = new Bird(&quot;Donald&quot;); 立即调用函数表达IIFEJavaScript 中的一个常见模式就是，函数在声明后立刻执行： 123(function () { console.log(&quot;Chirp, chirp!&quot;);})(); 这是一个匿名函数表达式，立即执行并输出 Chirp, chirp!。 请注意，函数没有名称，也不存储在变量中。 函数表达式末尾的两个括号（）会让它被立即执行或调用。 这种模式被叫做立即调用函数表达式（immediately invoked function expression) 或者IIFE。 使用 IIFE 创建一个模块一个立即调用函数表达式（IIFE）通常用于将相关功能分组到单个对象或者是 module 中。 例如，先前的挑战中定义了两个 mixins： 12345678910function glideMixin(obj) { obj.glide = function() { console.log(&quot;Gliding on the water&quot;); };}function flyMixin(obj) { obj.fly = function() { console.log(&quot;Flying, wooosh!&quot;); };} 我们可以将这些 mixins 分成以下模块： 1234567891011121314let motionModule = (function () { return { glideMixin: function(obj) { obj.glide = function() { console.log(&quot;Gliding on the water&quot;); }; }, flyMixin: function(obj) { obj.fly = function() { console.log(&quot;Flying, wooosh!&quot;); }; } }})(); 注意：一个立即调用函数表达式（IIFE）返回了一个 motionModule 对象。 返回的这个对象包含了作为对象属性的所有 mixin 行为。 module 模式的优点是，所有的运动相关的行为都可以打包成一个对象，然后由代码的其他部分使用。 下面是一个使用它的例子： 12motionModule.glideMixin(duck);duck.glide(); 对象模型的细节对象模型的细节 - JavaScript | MDN (mozilla.org) 基于类的（Java） 基于原型的（JavaScript） 类和实例是不同的事物。 所有对象均为实例。 通过类定义来定义类；通过构造器方法来实例化类。 通过构造器函数来定义和创建一组对象。 通过 new 操作符创建单个对象。 相同。 通过类定义来定义现存类的子类，从而构建对象的层级结构。 指定一个对象作为原型并且与构造函数一起构建对象的层级结构 遵循类链继承属性。 遵循原型链继承属性。 类定义指定类的所有实例的所有属性。无法在运行时动态添加属性。 构造器函数或原型指定实例的初始属性集。允许动态地向单个的对象或者整个对象集中添加或移除属性。 创建层级结构 12345678910111213141516171819202122232425262728function Employee () { this.name = &quot;&quot;; this.dept = &quot;general&quot;;}function Manager() { Employee.call(this);//继承Employee this.reports = [];}Manager.prototype = Object.create(Employee.prototype);function WorkerBee() { Employee.call(this);//继承Employee this.projects = [];}WorkerBee.prototype = Object.create(Employee.prototype);function SalesPerson() { WorkerBee.call(this);//继承WorkerBee this.dept = 'sales'; this.quota = 100;}SalesPerson.prototype = Object.create(WorkerBee.prototype);function Engineer() { WorkerBee.call(this);//继承WorkerBee this.dept = 'engineering'; this.machine = '';}Engineer.prototype = Object.create(WorkerBee.prototype); 继承属性假设您通过如下语句创建一个mark对象作为 WorkerBee的实例： 1var mark = new WorkerBee; 当 JavaScript 执行 new 操作符时，它会先创建一个普通对象，并将这个普通对象中的 [[prototype]] 指向 WorkerBee.prototype ，然后再把这个普通对象设置为执行 WorkerBee 构造函数时 this 的值。该普通对象的 [[Prototype]] 决定其用于检索属性的原型链。当构造函数执行完成后，所有的属性都被设置完毕，JavaScript 返回之前创建的对象，通过赋值语句将它的引用赋值给变量 mark。 这个过程不会显式的将 mark所继承的原型链中的属性作为本地属性存放在 mark 对象中。当访问属性时，JavaScript 将首先检查对象自身中是否存在该属性，如果有，则返回该属性的值。如果不存在，JavaScript 会检查原型链（使用内置的 [[Prototype]] ）。如果原型链中的某个对象包含该属性，则返回这个属性的值。如果遍历整条原型链都没有找到该属性，JavaScript 则认为对象中不存在该属性，返回一个 undefined。这样，mark 对象中将具有如下的属性和对应的值： 123mark.name = &quot;&quot;;mark.dept = &quot;general&quot;;mark.projects = []; mark 对象从 mark.__proto__ 中保存的原型对象里继承了 name 和 dept 属性。并由 WorkerBee 构造函数为 projects 属性设置了本地值。 1this.name = name || &quot;&quot;; JavaScript 的逻辑或操作符（||）会对第一个参数进行判断。如果该参数值运算后结果为真，则操作符返回该值。否则，操作符返回第二个参数的值。因此，这行代码首先检查 name 是否是对name 属性有效的值。如果是，则设置其为 this.name 的值。否则，设置 this.name 的值为空的字符串。 原型链「每日一题」什么是 JS 原型链？ - 知乎 (zhihu.com) (77条消息) JS原型对象和对象原型的区别_Hevttc_Cao的博客-CSDN博客_原型对象和对象原型的区别 (77条消息) 详解JS原型与原型链_小杰学前端的博客-CSDN博客_js原型和原型链 每个对象都可以有一个原型_proto_，这个原型还可以有它自己的原型，以此类推，形成一个原型链。查找特定属性的时候，我们先去这个对象里去找，如果没有的话就去它的原型对象里面去，如果还是没有的话再去向原型对象的原型对象里去寻找…… 这个操作被委托在整个原型链上，这个就是我们说的原型链了。 ​ 原型指针prototype: prototype属性，它是函数所独有的，它是从一个函数指向一个对象。它的含义是函数的原型对象，也就是这个函数（其实所有函数都可以作为构造函数）所创建的实例的原型对象; 这个属性是一个指针，指向一个对象，这个对象的用途就是包含所有实例共享的属性和方法（我们把这个对象叫做原型对象）; JavaScript规定,每一个构造函数都有一个prototype属性, 指向另一个对象。注意这个prototype就是一个对象,这个对象的所有属性和方法,都会被构造函数所拥有。 我们可以把那些不变的方法,直接定义在prototype对象上,这样所有对象的实例就可以共享这些方法。 _proto_: proto 是原型链查询中实际用到的，它总是指向 prototype，换句话说就是指向构造函数的原型对象，它是对象独有的。注意，为什么Foo构造也有这个属性呢，因为再js的宇宙里万物皆对象，包括函数； 对象都会有一个属性_ proto_指向构造函数的 prototype原型对象,之所以我们对象可以使用构造函数prototype原型对象的属性和方法,就是因为对象有_proto_ 原型的存在。 带键的集合123456789101112131415161718var sayings = new Map();sayings.set('dog', 'woof');sayings.set('cat', 'meow');sayings.set('elephant', 'toot');sayings.size; // 3sayings.get('fox'); // undefinedsayings.has('bird'); // falsesayings.delete('dog');sayings.has('dog'); // falsefor (var [key, value] of sayings) { console.log(key + ' goes ' + value);}// &quot;cat goes meow&quot;// &quot;elephant goes toot&quot;sayings.clear();sayings.size; // 0 Map函数12345678910111213141516const users = [ { name: 'John', age: 34 }, { name: 'Amy', age: 20 }, { name: 'camperCat', age: 10 }];const names = users.map(user=&gt;{ return{ &quot;name&quot;:user.name, &quot;age&quot;:user.age }})const names = users.map(user =&gt; user.name);console.log(names); Map与Object比较一般地，objects会被用于将字符串类型映射到数值。Object允许设置键值对、根据键获取值、删除键、检测某个键是否存在。而Map具有更多的优势。 Object的键均为Strings类型，在Map里键可以是任意类型。 必须手动计算Object的尺寸，但是可以很容易地获取使用Map的尺寸。 Map的遍历遵循元素的插入顺序。 Object有原型，所以映射中有一些缺省的键。（可以用 map = Object.create(null) 回避）。 这三条提示可以帮你决定用Map还是Object： 如果键在运行时才能知道，或者所有的键类型相同，所有的值类型相同，那就使用Map。 如果需要将原始值存储为键，则使用Map，因为Object将每个键视为字符串，不管它是一个数字值、布尔值还是任何其他原始值。 如果需要对个别元素进行操作，使用Object。 WeakMap对象WeakMap对象也是键值对的集合。它的键必须是对象类型，值可以是任意类型。它的键被弱保持，也就是说，当其键所指对象没有其他地方引用的时候，它会被 GC 回收掉。WeakMap提供的接口与Map相同。 与Map对象不同的是，WeakMap的键是不可枚举的。不提供列出其键的方法。列表是否存在取决于垃圾回收器的状态，是不可预知的。 对象内部的私有数据和方法被存储在WeakMap类型的privates变量中。所有暴露出的原型和情况都是公开的，而其他内容都是外界不可访问的，因为模块并未导出privates对象。 123456789101112131415const privates = new WeakMap();function Public() { const me = { // Private data goes here }; privates.set(this, me);}Public.prototype.method = function () { const me = privates.get(this); // Do stuff with private data in `me`...};module.exports = Public; 集合Set对象Set对象是一组值的集合，这些值是不重复的，可以按照添加顺序来遍历。 123456789101112var mySet = new Set();mySet.add(1);mySet.add(&quot;some text&quot;);mySet.add(&quot;foo&quot;);mySet.has(1); // truemySet.delete(&quot;foo&quot;);mySet.size; // 2for (let item of mySet) console.log(item);// 1// &quot;some text&quot; 数组与集合之间转换可以使用Array.from或展开操作符来完成集合到数组的转换。同样，Set的构造器接受数组作为参数，可以完成从Array到Set的转换。需要重申的是，Set对象中的值不重复，所以数组转换为集合时，所有重复值将会被删除。 1234Array.from(mySet);[...mySet2];mySet2 = new Set([1,2,3,4]); Array和Set的对比 数组中用于判断元素是否存在的indexOf 函数效率低下。 Set对象允许根据值删除元素，而数组中必须使用基于下标的 splice 方法。 数组的indexOf方法无法找到NaN值。 Set对象存储不重复的值，所以不需要手动处理包含重复值的情况。 WeakSet对象与Set对象的主要区别有： WeakSets中的值必须是对象类型，不可以是别的类型 WeakSet的“weak”指的是，对集合中的对象，如果不存在其他引用，那么该对象将可被垃圾回收。于是不存在一个当前可用对象组成的列表，所以WeakSets不可枚举 WeakSet的用例很有限，比如使用 DOM 元素作为键来追踪它们而不必担心内存泄漏。 错误处理你可以用 throw 语句抛出一个异常并且用 try...catch 语句捕获处理它。 catch 块你可以使用catch块来处理所有可能在try块中产生的异常。 finally块finally块包含了在 try 和 catch 块完成后、下面接着 try…catch 的语句之前执行的语句。finally块无论是否抛出异常都会执行。如果抛出了一个异常，就算没有异常处理，finally块里的语句也会执行。 12345678openMyFile();try { writeMyFile(theData); //This may throw a error}catch(e){ handleError(e); // If we got a error we handle it}finally { closeMyFile(); // always close the resource} 123456789101112131415161718function getMonthName(mo) { mo = mo - 1; // Adjust month number for array index (1 = Jan, 12 = Dec) var months = [&quot;Jan&quot;,&quot;Feb&quot;,&quot;Mar&quot;,&quot;Apr&quot;,&quot;May&quot;,&quot;Jun&quot;,&quot;Jul&quot;, &quot;Aug&quot;,&quot;Sep&quot;,&quot;Oct&quot;,&quot;Nov&quot;,&quot;Dec&quot;]; if (months[mo]) { return months[mo]; } else { throw &quot;InvalidMonthNo&quot;; //throw keyword is used here }}try { // statements to try monthName = getMonthName(myMonth); // function could throw exception}catch (e) { monthName = &quot;unknown&quot;; logMyErrors(e); // pass exception object to error handler -&gt; yor own function} 作用域（作用域链）作用域是在程序运行时代码中的某些特定部分中变量、函数和对象的可访问性。 (77条消息) 深入理解JS作用域和作用域链_码上十七的博客-CSDN博客_js作用域链的理解 (77条消息) JS 作用域和作用域链_destinytaoer的博客-CSDN博客_js作用域和作用域链 BOMJS BOM（浏览器对象模型） (biancheng.net) DOMDOM 概述 - Web API 接口参考 | MDN (mozilla.org) JSON JavaScript 类型 JSON 的不同点 对象和数组 属性名称必须是双引号括起来的字符串；最后一个属性后不能有逗号。 数值 禁止出现前导零（ JSON.stringify 方法自动忽略前导零，而在 JSON.parse 方法中将会抛出 SyntaxError）；如果有小数点，则后面至少跟着一位数字。 字符串 只有有限的一些字符可能会被转义；禁止某些控制字符； Unicode 行分隔符（U+2028）和段分隔符（U+2029）被允许 ; 字符串必须用双引号括起来。请参考下面的示例，可以看到 JSON.parse() 能够正常解析，但将其当作 JavaScript 解析时会抛出 SyntaxError 错误：let code = '&quot;\\u2028\\u2029&quot;'; JSON.parse(code); // 正常 eval(code); // 错误 在JSONNumber（数字内部不允许包含空格）或JSONString（字符串内部的空格被解释为相应的字符，否则就有问题了）之外的任何位置可以有多余的空白字符。JSON 只支持这些空白字符： 制表符（U+0009），回车（U+000D），换行（U+000A）以及空格（U+0020）。 JSON.parse() 解析 JSON 字符串并返回对应的值，可以额外传入一个转换函数，用来将生成的值和其属性，在返回之前进行某些修改。 JSON.stringify() 返回与指定值对应的 JSON 字符串，可以通过额外的参数，控制仅包含某些属性，或者以自定义方法来替换某些 key 对应的属性值。 AJAXAJAX 是异步的 JavaScript 和 XML（Asynchronous JavaScript And XML）。简单点说，就是使用 XMLHttpRequest 对象与服务器通信。 它可以使用 JSON，XML，HTML 和 text 文本等格式发送和接收数据。AJAX 最吸引人的就是它的“异步”特性，也就是说它可以在不重新刷新页面的情况下与服务器通信，交换数据，或更新页面。 你可以使用 AJAX 最主要的两个特性做下列事： 在不重新加载页面的情况下发送请求给服务器。 接受并使用从服务器发来的数据。 Step1——发送http请求创建一个包含必要函数功能的对象实例（XMLHttpRequest） 12345// 创建XMLHttp 实例if (window.XMLHttpRequest) { // Mozilla, Safari, IE7+ ... httpRequest = new XMLHttpRequest();} else if (window.ActiveXObject) { // IE 6 and older httpRequest = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;); 发送请求后会收到响因，此时需要告知 XMLHttp 请求对象是由哪一个 JavaScript 函数处理响应，在设置了对象的 onreadystatechange 属性后给他命名，当请求状态改变时调用函数。 1httpRequest.onreadystatechange = nameOfTheFunction; 要注意的是，函数名后没有参数，因为你把一个引用赋值给了函数，而不是真正的调用了它。 此外，如果不使用函数名的方式，你还可以用 JavaScript 的匿名函数响应处理的动作，就像下面这样： 123httpRequest.onreadystatechange = function(){ // Process the server response here.}; 接下来，声明当你接到响应后要做什么，你要发送一个实际的请求，通过调用 HTTP 请求对象的 open() 和 send() 方法，像下面这样： 12httpRequest.open('GET', 'http://www.example.org/some.file', true);httpRequest.send(); open() 的第一个参数是 HTTP 请求方法 - 有 GET，POST，HEAD 以及服务器支持的其他方法。 保证这些方法一定要是大写字母，否则其他一些浏览器（比如 FireFox）可能无法处理这个请求。更多关于 HTTP 的请求方法，可以查看 W3C specs。 第二个参数是你要发送的 URL。由于安全原因，默认不能调用第三方 URL 域名。 确保你在页面中使用的是正确的域名，否则在调用 open() 方法是会有 “permission denied” 错误提示。一个容易犯的错误是你企图通过 domain.tld 访问网站， 而不是使用 www.domain.tld。如果你真的需要向另一个域名发送请求，可以查看 HTTP access control。 第三个参数是可选的，用于设置请求是否是异步的。如果设为 true (默认值)，即开启异步，JavaScript 就不会在此语句阻塞，使得用户能在服务器还没有响应的情况下与页面进行交互。 send() 方法的参数可以是任何你想发送给服务器的内容，如果是 POST 请求的话。发送表单数据时应该用服务器可以解析的格式，像查询语句： 1&quot;name=value&amp;anothername=&quot;+encodeURIComponent(myVar)+&quot;&amp;so=on&quot; 如果你使用 POST 数据，那就需要设置请求的 MIME 类型。比如，在调用 send() 方法获取表单数据前要有下面这个： 1httpRequest.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded'); Step2——处理服务器响因在发送请求时，你提供的 JavaScript 函数名负责处理响应： 1httpRequest.onreadystatechange = nameOfTheFunction; 这个函数应该做什么？首先，函数要检查请求的状态。如果状态的值是 XMLHttpRequest.DONE （对应的值是 4），意味着服务器响应收到了并且是没问题的，然后就可以继续执行。 12345if (httpRequest.readyState === XMLHttpRequest.DONE) { // Everything is good, the response was received.} else { // Not ready yet.} 全部 readyState 状态值都在 XMLHTTPRequest.readyState，如下也是： 0 (未初始化) or (请求还未初始化) 1 (正在加载) or (已建立****服务器链接) 2 (加载成功) or (请求已接受) 3 (交互) or (正在处理请求) 4 (完成) or (请求已完成并且响应已准备好) 接下来，点击 HTTP 响应的 response code。 可能的响应码都已经列在 W3C这个列表里。在下面的例子中，我们通过检查响应码 200 OK 判断 AJAX 有没有成功。 1234567if (httpRequest.status === 200) { // Perfect!} else { // There was a problem with the request. // For example, the response may have a 404 (Not Found) // or 500 (Internal Server Error) response code.} 在检查完请求状态和 HTTP 响应码后， 你就可以用服务器返回的数据做任何你想做的了。你有两个方法去访问这些数据： httpRequest.responseText – 服务器以文本字符的形式返回 httpRequest.responseXML – 以 XMLDocument 对象方式返回，之后就可以使用 JavaScript 来处理 注意上面这一步只在你发起异步请求时有效（即 open() 的第三个参数未特别指定或设为 true）。如果你你发起的是同步请求则不必使用函数，但是非常不推荐这样子做，它的用户体验很糟糕。 Step3——简单的http请求这个 JavaScript 会请求一个 HTML 文档 test.html，包含 “I’m a test” 内容。然后我们 alert() 响应的内容。注意这个例子我们只是用了 JavaScript，没有用 jQuery。而且，HTML，XML 和 PHP 文件都要放在用一个目录下。 123456789101112131415161718192021222324252627282930&lt;button id=&quot;ajaxButton&quot; type=&quot;button&quot;&gt;Make a request&lt;/button&gt;&lt;script&gt;(function() { var httpRequest; document.getElementById(&quot;ajaxButton&quot;).addEventListener('click', makeRequest); function makeRequest() { httpRequest = new XMLHttpRequest(); if (!httpRequest) { alert('Giving up :( Cannot create an XMLHTTP instance'); return false; } httpRequest.onreadystatechange = alertContents; httpRequest.open('GET', 'test.html'); httpRequest.send(); } function alertContents() { if (httpRequest.readyState === XMLHttpRequest.DONE) { if (httpRequest.status === 200) { alert(httpRequest.responseText); } else { alert('There was a problem with the request.'); } } }})();&lt;/script&gt; 用户点击 “Make a request” 按钮； 事件处理调用 makeRequest() 函数； 请求已通过然后（onreadystatechange）传给 alertContents() 执行。 alertContents() 检查返回的响应是否 OK，然后 alert() test.html 文件内容。 Note: 如果你向一个代码片段发送请求，将返回 XML，而不是静态 XML 文件，在 IE 浏览器上则必须要设置响应头才能正常工作。如果不设置响应头为 Content-Type:application/xml ，IE 浏览器会在你访问 XML 元素时抛出 “Object Expected” 错误。 Note 2: 如果不设置响应头 Cache-Control: no-cache 浏览器将会把响应缓存下来而且再也无法重新提交请求。你也可以添加一个总是不同的 GET 参数，比如时间戳或者随机数 (详情见 bypassing the cache) Note 3: 如果变量 httpRequest 在全局范围内使用，它会在 makeRequest() 函数中被相互覆盖，从而导致资源竞争。为了避免这个情况，请在包含 AJAX 函数的闭包中声明 httpRequest 变量。 在通信错误的事件中（例如服务器宕机），在访问响应状态 onreadystatechange 方法中会抛出一个例外。为了缓和这种情况，则可以使用 try...catch 把 if...then 语句包裹起来。 1234567891011121314function alertContents() { try { if (httpRequest.readyState === XMLHttpRequest.DONE) { if (httpRequest.status === 200) { alert(httpRequest.responseText); } else { alert('There was a problem with the request.'); } } } catch( e ) { alert('Caught Exception: ' + e.description); }} Step4——处理XML响因在上一个例子中，在收到 HTTP 请求的响应后我们会请求对象的 responseText 属性，包含 test.html 文件的内容。现在我们试试 responseXML 属性。 首先，我们创建一个稍后将要请求的有效的 XML 文档。文档（test.html）包含以下内容： 1234&lt;?xml version=&quot;1.0&quot; ?&gt;&lt;root&gt; I'm a test.&lt;/root&gt; 在脚本里我们只需要把请求行改为： 123...onclick=&quot;makeRequest('test.xml')&quot;&gt;... 然后在 alertContents() 里，我们把 alert(httpRequest.responseText) 改为： 123var xmldoc = httpRequest.responseXML;var root_node = xmldoc.getElementsByTagName('root').item(0);alert(root_node.firstChild.data); 这部分代码采用 responseXML 提供的 XMLDocument 对象，并使用 DOM 方法访问 XML 文档中包含的一些数据。你可以在这里查看 test.xml 并且在这里更新测试代码。 HTTP请求报文ES6在 JavaScript 里，我们会经常遇到不需要给函数命名的情况，尤其是在需要将一个函数作为参数传给另外一个函数的时候。 这时，我们会创建匿名函数。 因为这些函数不会在其他地方复用，所以我们不需要给它们命名。 这种情况下，我们通常会使用以下语法： 1234const myFunc = function() { const myVar = &quot;value&quot;; return myVar;} ES6 提供了其他写匿名函数的方式的语法糖。 你可以使用箭头函数： 1234const myFunc = () =&gt; { const myVar = &quot;value&quot;; return myVar;} 当不需要函数体，只返回一个值的时候，箭头函数允许你省略 return 关键字和外面的大括号。 这样就可以将一个简单的函数简化成一个单行语句。 1const myFunc = () =&gt; &quot;value&quot;; 这段代码默认会返回字符串 value。 简洁写法1const multiplier = (item, multi) =&gt; item * multi; 1234567891011const getMousePosition = (x, y) =&gt; { return { x: x, y: y }};const getMousePosition = (x, y) =&gt; ({ x: x, y: y});const getMousePosition = (x, y) =&gt; ({ x, y }); ()=&gt;{return{}}==()=&gt;({}) 默认参数1const greeting = (name = &quot;Anonymous&quot;) =&gt; &quot;Hello &quot; + name; rest操作符rest 操作符可以用于创建有一个变量来接受多个参数的函数。 这些参数被储存在一个可以在函数内部读取的数组中。 123function howMany(...args) { return &quot;You have passed &quot; + args.length + &quot; arguments.&quot;;} sum 函数可以接收任意数量的参数，并返回它们的总和。 123const sum = (...args) =&gt; { return args.reduce((a, b) =&gt; a + b, 0);} 展开操作符将数组展开成一系列由逗号分隔的参数 123const arr = [6, 89, 3, 45];const [a, b, ...arr] = [1, 2, 3, 4, 5, 7];const maximus = Math.max(...arr); 解构赋值12345678910111213141516const user = { name: 'John Doe', age: 34 };const { name, age } = user;const { name: userName, age: userAge } = user;//解构嵌套对象中的值const user = { johnDoe: { age: 34, email: 'johnDoe@freeCodeCamp.com' }};const { johnDoe: { age: userAge, email: userEmail }} = user;//函数参数中解构对象const profileUpdate = ({ name, age, nationality, location }) =&gt; {} 解构数组12345678const [a, b] = [1, 2, 3, 4, 5, 6];console.log(a, b);//1, 2const [a, b,,, c] = [1, 2, 3, 4, 5, 6];console.log(a, b, c);//1, 2, 5const [a, b, ...arr] = [1, 2, 3, 4, 5, 7];console.log(a, b);//1, 2console.log(arr);//[3, 4, 5, 7] 模板字符串12345678910const person = { name: &quot;Zodiac Hasbro&quot;, age: 56};const greeting = `Hello, my name is ${person.name}!I am ${person.age} years old.`;console.log(greeting);// Hello, my name is Zodiac Hasbro! 和 I am 56 years old. 编写简洁的对象字面量声明123456const getMousePosition = (x, y) =&gt; ({ x: x, y: y});//getMousePosition 简单的函数，返回拥有两个属性的对象。 ES6 提供了一个语法糖，消除了类似 x: x 这种冗余的写法。 你可以只写一次 x，解释器会自动将其转换成 x: x（或效果相同的内容）。 下面是使用这种语法重写的同样的函数：const getMousePosition = (x, y) =&gt; ({ x, y }); 编写简洁的函数说明123456789101112const person = { name: &quot;Taylor&quot;, sayHello: function() { return `Hello! My name is ${this.name}.`; }};const person = { name: &quot;Taylor&quot;, sayHello() { return `Hello! My name is ${this.name}.`; }}; class语法构建函数12345678910111213const person = { name: &quot;Taylor&quot;, sayHello() { return `Hello! My name is ${this.name}.`; }};//class的应用class SpaceShuttle { constructor(targetPlanet) { this.targetPlanet = targetPlanet; }}const zeus = new SpaceShuttle('Jupiter'); 123456789101112class Book { constructor(author) { this._author = author; } // getter(变量名不能与get或set重名（author!=writer）) get writer() { return this._author; } // setter set writer(updatedAuthor) { this._author = updatedAuthor; } 模块脚本为了让 JavaScript 更模块化、更整洁以及更易于维护，ES6 引入了在多个 JavaScript 文件之间共享代码的机制。 它可以导出文件的一部分供其它文件使用，然后在需要它的地方按需导入。 为了使用这一功能， 需要在 HTML 文档里创建一个 type 为 module 的脚本。 例子如下： 1&lt;script type=&quot;module&quot; src=&quot;filename.js&quot;&gt;&lt;/script&gt; 假设有一个文件 math_functions.js，该文件包含了数学运算相关的一些函数。 其中一个存储在变量 add 里，该函数接受两个数字作为参数返回它们的和。 你想在几个不同的 JavaScript 文件中使用这个函数。 要实现这个目的，就需要 export 它。 12345678910111213141516171819export const add = (x, y) =&gt; { return x + y;}/////const add = (x, y) =&gt; { return x + y;}export { add, subtract };//默认导出的 export,在文件中只有一个值需要导出的时候，通常会使用这种语法。 它也常常用于给文件或者模块创建返回值。//命名函数export default function add(x, y) { return x + y;}//匿名函数export default function(x, y) { return x + y;}//导出方式import add from &quot;./math_functions.js&quot;; import 可以导入文件或模块的一部分。 在之前的课程里，例子从 math_functions.js 文件里导出了 add。 下面看一下如何在其它文件导入它： 123456import { add, subtract } from './math_functions.js';uppercaseString(&quot;hello&quot;);import * as myMathModule from &quot;./math_functions.js&quot;;stringFunctions.uppercaseString(&quot;hello&quot;);stringFunctions.lowercaseString(&quot;WORLD!&quot;); PromisePromise 是异步编程的一种解决方案 - 它在未来的某时会生成一个值。 任务完成，分执行成功和执行失败两种情况。 Promise 是构造器函数，需要通过 new 关键字来创建。 构造器参数是一个函数，该函数有两个参数 - resolve 和 reject。 通过它们来判断 promise 的执行结果。 用法如下： 123const myPromise = new Promise((resolve, reject) =&gt; {}); Promise 有三个状态：pending、fulfilled 和 rejected。上述例子里创建的 promise 一直阻塞在 pending 状态里，因为没有调用 promise 的完成方法。 Promise 提供的 resolve 和 reject 参数就是用来结束 promise 的。 Promise 成功时调用 resolve，promise 执行失败时调用 reject， 如下文所述，这些方法需要有一个参数。 1234567891011const myPromise = new Promise((resolve, reject) =&gt; { if(condition here) { resolve(&quot;Promise was fulfilled&quot;); } else { reject(&quot;Promise was rejected&quot;); }});//回调函数myPromise.then(result =&gt; { }); 当 promise 完成 resolve 时会触发 then 方法。 123myPromise.then(result =&gt; {}); 当 promise 失败时会调用 catch 方法。 当 promise 的 reject 方法执行时会直接调用。 用法如下： 123myPromise.catch(error =&gt; {}); 正则表达式创建正则表达式1234//1.包含在斜杠之间var re = /ab+c/;//2.调用RegExp对象的构造函数var re = new RegExp(&quot;ab+c&quot;); 简单模式/abc/能且仅能匹配 “abc” 字符按照顺序同时出现的情况。比如”Grab crab” 会匹配失败，因为中间存在空格使得abc不连续 断言表示一个匹配在某些条件下发生。断言包含先行断言、后行断言和条件表达式。 边界类断言 字符 含义 ^ 匹配输入的开头，多行模式为true时，可以匹配字符串开头（字符串的开始位置），也可以匹配行的开头（即换行符\\n之后的位置）（/^A/ 匹配不了 “an A” 里面的 “A”，但是可以匹配 “An A” 里面第一个 “A”。） $ 匹配输入的结束，多行模式为true时，可以匹配字符串结尾（字符串的结束位置）, 也可以匹配行的结尾（即换行符\\n之前的位置）（比如 /t$/ 不能匹配 “eater” 中的 “t”，但是可以匹配 “eat” 中的 “t”。） \\b 匹配一个单词的边界，这是一个字的字符前后没有另一个字的字符位置，例如在字母和空格之间。(/\\bm/在 “moon” 中匹配到 “m”)(/oo\\b/在 “moon” 中不会匹配到 “oo”, 因为 “oo” 后面跟着 “n” 这个单词字符)(/oon\\b/在 “moon” 中匹配 “oon”， 因为 “oon” 是这个字符串的结尾，因此后面没有单词字符)（/\\w\\b\\w/将永远不会匹配任何东西，因为一个单词字符后面永远不会有非单词字符和单词字符。） \\B 匹配非单词边界。这是上一个字符和下一个字符属于同一类型的位置：要么两者都必须是单词，要么两者都必须是非单词，例如在两个字母之间或两个空格之间。字符串的开头和结尾被视为非单词。与匹配的词边界相同，匹配的非词边界也不包含在匹配中。例如，/\\Bon/ 在 “at noon” 中匹配 “on” ，/ye\\B/ 在 “possibly yesterday”中匹配”ye” 。 12345678910111213141516171819//例1 （匹配输入的开头）let fruits = [&quot;Apple&quot;, &quot;Watermelon&quot;, &quot;Orange&quot;, &quot;Avocado&quot;, &quot;Strawberry&quot;];// 使用正则 /^A/ 选择以'A'开头的水果。// 这里的 '^' 只有一种含义：匹配输入的开头。let fruitsStartsWithA = fruits.filter(fruit =&gt; /^A/.test(fruit));console.log(fruitsStartsWithA); // [ 'Apple', 'Avocado' ]//例2 匹配不是 ‘A’开头的let fruits = [&quot;Apple&quot;, &quot;Watermelon&quot;, &quot;Orange&quot;, &quot;Avocado&quot;, &quot;Strawberry&quot;];// 使用正则 /^[^A]/ 选择 不是以 ‘A’ 开头的水果// 在这个例子中，“^” 控件符号表示两种含义：// 1) 匹配输入的开头// 2) 一个否定的字符集: [^A] ，意思是匹配不是 ‘A’ 的字符let fruitsStartsWithNotA = fruits.filter(fruit =&gt; /^[^A]/.test(fruit));console.log(fruitsStartsWithNotA); // [ 'Watermelon', 'Orange', 'Strawberry' ] 其他断言 字符 含义 x(?=y) 向前断言： x 被 y 跟随时匹配 x。例如，对于/Jack(?=Sprat)/，“Jack”在跟有“Sprat”的情况下才会得到匹配．`/Jack(?=Sprat x(?!y) 向前否定断言： x 没有被 y 紧随时匹配 x。例如，对于/\\d+(?!\\.)/，数字后没有跟随小数点的情况下才会得到匹配。对于/\\d+(?!\\.)/.exec(3.141)，匹配‘141’而不是‘3’。 (?&lt;=y)x 向后断言： x 跟随 y 的情况下匹配 x。例如，对于/(?&lt;=Jack)Sprat/，“Sprat”紧随“Jack”时才会得到匹配。对于`/(?&lt;=Jack (?&lt;!y)x 向后否定断言： x 不跟随 y 时匹配 x。例如，对于/(?&lt;!-)\\d+/，数字不紧随 - 符号的情况下才会得到匹配。对于/(?&lt;!-)\\d+/.exec(3) ，“3”得到匹配。 而/(?&lt;!-)\\d+/.exec(-3)的结果无匹配，这是由于数字之前有 - 符号。 字符类 字符 含义 . 匹配除行终止符之外的任何单个字符(/.y/ 在“yes make my day”中匹配“my”和“ay”，而不是“yes”，而/y./匹配的是“ye”与“y”) \\d 匹配任何数字 (阿拉伯数字)。相当于 [0-9]。例如，/\\d/ 或 /[0-9]/ 匹配“B2is the suite number”中的“2”。 \\D 匹配任何非数字 (阿拉伯数字) 的字符。相当于[^0-9]。例如，/\\D/ 或者 /[^0-9]/ 匹配“B2 is the suite number”中的“B”。 \\w 匹配基本拉丁字母中的任何字母数字字符，包括下划线。相当于 [A-Z，a-z，0-9，_]。例如，/\\w/ 匹配“apple”中的“a”，“p”，“p”，“l”，“e”，匹配“$5.28”中的“5”，匹配“3D”中的“3”，以及匹配“Émanuel”中的“m”。 \\W 匹配任何不是来自基本拉丁字母的单词字符。相当于 [^A-Za-z0-9_]。例如，/\\W/ 或者 /[^A-Za-z0-9_]/ 匹配“50%”中的“%”，以及匹配“Émanuel”中的“É”。 \\s 匹配单个空白字符，包括空格、制表符、换页符、换行符和其他 Unicode 空格。相当于 [ \\f\\n\\r\\t\\v\\u00a0\\u1680\\u2000-\\u200a\\u2028\\u2029\\u202f\\u205f\\u3000\\ufeff]。例如，/\\s\\w*/ 匹配“foo bar”中的“ bar”。 \\S 匹配除空格以外的单个字符。相当于 [^ \\f\\n\\r\\t\\v\\u00a0\\u1680\\u2000-\\u200a\\u2028\\u2029\\u202f\\u205f\\u3000\\ufeff]。例如，/\\S\\w*/ 匹配“foo bar”中的“foo”。 \\t 匹配水平制表符。 \\r 匹配回车符。 \\n 匹配换行符。 \\v 匹配垂直制表符。 \\f 匹配换页符。 [\\b] 匹配退格键。如果您正在寻找单词边界字符（\\b） \\0 匹配一个 NUL 字符。不要在此后面加上另一个数字。 \\cX 使用插入符号匹配控制字符，其中“X”是 A–Z 中的一个字母（对应于代码点 U+0001–U+001F）。例如，/\\cM\\cJ/匹配“\\r\\n”。 \\xhh 匹配与代码 *hh*（两个十六进制数字）对应的字符。 \\uhhhh 匹配与值 *hhhh*（四个十六进制数字）对应的 UTF-16 代码单元。 \\u{hhhh} 或 \\u{hhhhh} （仅当设置了 u 标志时。）匹配与 Unicode 值 U+*hhhh* 或 U+*hhhhh*（十六进制数字）对应的字符。 使用特殊字符当你需要匹配一个不确定的字符串时，比如寻找一个或多个 “b”，或者寻找空格，可以在模式中使用特殊字符。比如，你可以使用 /ab*c/ 去匹配一个单独的 “a” 后面跟了零个或者多个 “b”，同时后面跟着 “c” 的字符串：*的意思是前一项出现零次或者多次。在字符串 “abbbbc” 中，这个模式匹配了子字符串 “abbbbc”。 [-6,-1,5,4,1,-8,6,7,-3,6,0,-6,-7,8,-8,-4,1] 应用如果想要在字符串 The dog chased the cat 中匹配到 the 这个单词，可以使用如下正则表达式：/the/。 注意，正则表达式中不需要引号。 JavaScript 中有多种使用正则表达式的方法。 测试正则表达式的一种方法是使用 .test() 方法。 .test() 方法会把编写的正则表达式和字符串（即括号内的内容）完全匹配（区分大小写），如果成功匹配到字符，则返回 true，反之，返回 false。 123let testStr = &quot;freeCodeCamp&quot;;let testRegex = /Code/;testRegex.test(testStr); 搜索多个模式|这对于搜寻单个字符串非常有用，但仅限于一种匹配模式。 你可以使用 alternation 或 OR 操作符搜索多个模式： | 此操作符匹配操作符前面或后面的字符。 例如，如果你想匹配 yes 或 no，你需要的正则表达式是 /yes|no/。 你还可以匹配多个规则，这可以通过添加更多的匹配模式来实现。 这些匹配模式将包含更多的 OR 操作符来分隔它们，比如/yes|no|maybe/。 1let petRegex = /dog|cat|bird|fish/ 匹配忽略大小写可以使用标志（flag）来匹配这两种情况。 标志有很多，不过这里我们只关注忽略大小写的标志——i。 可以通过将它附加到正则表达式之后来使用它。 这里给出使用该标志的一个实例 /ignorecase/i。 这个字符串可以匹配字符串 ignorecase、igNoreCase 和 IgnoreCase。 123let myString = &quot;freeCodeCamp&quot;;let fccRegex = /freecodecamp/i; // 修改这一行let result = fccRegex.test(myString); 提取找到的实际匹配项match提取或搜寻一次模式匹配 12345&quot;Hello, World!&quot;.match(/Hello/);let ourStr = &quot;Regular expressions&quot;;let ourRegex = /expressions/;ourStr.match(ourRegex);//这里第一个 match 将返回 [&quot;Hello&quot;] 第二个将返回 [&quot;expressions&quot;]。 多次搜寻或提取模式匹配g 12let repeatRegex = /Repeat/g;testStr.match(repeatRegex); 在正则表达式上可以有多个标志，比如 /search/gi 用通配符匹配任何内容.通配符 . 将匹配任何一个字符。 通配符也叫 dot 或 period。 可以像使用正则表达式中任何其他字符一样使用通配符。 例如，如果想匹配 hug、huh、hut 和 hum，可以使用正则表达式 /hu./ 匹配以上四个单词。 12345let humStr = &quot;I'll hum a song&quot;;let hugStr = &quot;Bear hug&quot;;let huRegex = /hu./;huRegex.test(humStr);huRegex.test(hugStr); 将单个字符与多种可能性匹配可以使用字符集 （character classes）更灵活的匹配字符。 可以把字符集放在方括号（[ 和 ]）之间来定义一组需要匹配的字符串。 例如，如果想要匹配 bag、big 和 bug，但是不想匹配 bog。 可以创建正则表达式 /b[aiu]g/ 来执行此操作。 [aiu] 是只匹配字符 a、i 或者 u 的字符集。 在字符集中，可以使用连字符（-）来定义要匹配的字符范围。 例如，要匹配小写字母 a 到 e，你可以使用 [a-e]。 使用连字符（-）匹配字符范围并不仅限于字母。 它还可以匹配一系列数字。 例如，/[0-5]/ 匹配 0 和 5 之间的任意数字，包含 0 和 5。 此外，还可以在单个字符集中组合一系列字母和数字。 /[a-z0-9]/ig 123456789let bigStr = &quot;big&quot;;let bagStr = &quot;bag&quot;;let bugStr = &quot;bug&quot;;let bogStr = &quot;bog&quot;;let bgRegex = /b[aiu]g/;bigStr.match(bgRegex);bagStr.match(bgRegex);bugStr.match(bgRegex);bogStr.match(bgRegex); 匹配单个未指定的字符^（匹配字符串开始位置） 匹配输入字符串的开始位置，除非在方括号([])表达式中使用，当该符号在方括号表达式中使用时，表示不接受该方括号表达式中的字符集合。要匹配 ^ 字符本身，请使用 ^。 [^abcd] 创建一个不想匹配的字符集合。 这些类型的字符集称为否定字符集（ negated character sets）。 要创建否定字符集，需要在开始括号后面和不想匹配的字符前面放置脱字符（即^）。 例如，/[^aeiou]/gi 匹配所有非元音字符。 注意，字符 .、!、[、@、/ 和空白字符等也会被匹配，该否定字符集仅排除元音字符。 \\^abcd 匹配输入字符串开始位置 匹配出现一次或多次的字符+有时，需要匹配出现一次或者连续多次的的字符（或字符组）。 这意味着它至少出现一次，并且可能重复出现。 可以使用 + 符号来检查情况是否如此。 记住，字符或匹配模式必须一个接一个地连续出现。 这就是说，字符必须一个接一个地重复。 例如，/a+/g 会在 abc 中匹配到一个匹配项，并且返回 [&quot;a&quot;]。 因为 + 的存在，它也会在 aabc 中匹配到一个匹配项，然后返回 [&quot;aa&quot;]。 如果它是检查字符串 abab，它将匹配到两个匹配项并且返回[&quot;a&quot;, &quot;a&quot;]，因为a字符不连续，在它们之间有一个b字符。 最后，因为在字符串 bcd 中没有 a，因此找不到匹配项。 匹配出现零次或多次的字符*1234567let soccerWord = &quot;gooooooooal!&quot;;let gPhrase = &quot;gut feeling&quot;;let oPhrase = &quot;over the moon&quot;;let goRegex = /go*/;soccerWord.match(goRegex);//[&quot;goooooooo&quot;]gPhrase.match(goRegex);//[&quot;g&quot;]oPhrase.match(goRegex);//null 用惰性匹配来查找字符?在正则表达式中，贪婪（greedy）匹配会匹配到符合正则表达式匹配模式的字符串的最长可能部分，并将其作为匹配项返回。 另一种方案称为懒惰（lazy）匹配，它会匹配到满足正则表达式的字符串的最小可能部分。 可以将正则表达式 /t[a-z]*i/ 应用于字符串 &quot;titanic&quot;。 这个正则表达式是一个以 t 开始，以 i 结束，并且中间有一些字母的匹配模式。 正则表达式默认是贪婪匹配，因此匹配返回为 [&quot;titani&quot;]。 它会匹配到适合该匹配模式的最大子字符串。 但是，你可以使用 ? 字符来将其变成懒惰匹配。 调整后的正则表达式 /t[a-z]*?i/ 匹配字符串 &quot;titanic&quot; 返回 [&quot;ti&quot;]。 检查全部或无?有时，想要搜寻的匹配模式可能有不确定是否存在的部分。 尽管如此，还是想检查它们。 为此，可以使用问号 ? 指定可能存在的元素。 这将检查前面的零个或一个元素。 可以将此符号视为前面的元素是可选的。 例如，美式英语和英式英语略有不同，可以使用问号来匹配两种拼写。 12345let american = &quot;color&quot;;let british = &quot;colour&quot;;let rainbowRegex= /colou?r/;rainbowRegex.test(american);//truerainbowRegex.test(british);//true 匹配字符串结尾$12345let theEnding = &quot;This is a never ending story&quot;;let storyRegex = /story$/;storyRegex.test(theEnding);let noEnding = &quot;Sometimes a story will have to end&quot;;storyRegex.test(noEnding); 匹配所有的字母和数字\\wJavaScript 中与字母表匹配的最接近的元字符是\\w。 这个缩写等同于[A-Za-z0-9_]。 此字符类匹配大写字母和小写字母以及数字。 注意，这个字符类也包含下划线字符 (_)。 有可能想要搜寻的匹配模式是非字母数字字符。 可以使用 \\W 搜寻和 \\w 相反的匹配模式。 注意，相反匹配模式使用大写字母。 此缩写与 [^A-Za-z0-9_] 是一样的。 匹配所有数字\\d,\\D查找数字字符的缩写是 \\d，注意是小写的 d。 这等同于元字符 [0-9]，它查找 0 到 9 之间任意数字的单个字符。 查找非数字字符的缩写是 \\D。 这等同于字符串 [^0-9]，它查找不是 0 - 9 之间数字的单个字符。 匹配空白字符\\s可以使用 \\s 搜寻空格，其中 s 是小写。 此匹配模式将匹配空格、回车符、制表符、换页符和换行符。 可以认为这类似于元字符 [ \\r\\t\\f\\n\\v]。 使用 \\S 搜寻非空白字符，其中 s 是大写。 此匹配模式将不匹配空格、回车符、制表符、换页符和换行符。 可以认为这类似于元字符 [^ \\r\\t\\f\\n\\v]。 指定匹配的上限和下限可以使用数量说明符（quantity specifiers）指定匹配模式的上下限。 数量说明符与花括号（{ 和 }）一起使用。 可以在花括号之间放两个数字，这两个数字代表匹配模式的上限和下限。 例如，要匹配出现 3 到 5 次字母 a 的在字符串 ah，正则表达式应为/a{3,5}h/。 12345678910let A4 = &quot;aaaah&quot;;let A2 = &quot;aah&quot;;let multipleA = /a{3,5}h/;multipleA.test(A4);multipleA.test(A2);//============//修改正则表达式 ohRegex 以匹配出现 3 到 6 次字母 h 的字符串 Oh no。let ohStr = &quot;Ohhh no&quot;;let ohRegex = /Oh{3,6}\\sno/g; // 修改这一行let result = ohRegex.test(ohStr); 只指定匹配的下限 在第一个数字后面跟一个逗号即可。 例如，要匹配至少出现 3 次字母 a 的字符串 hah，正则表达式应该是 /ha{3,}h/ 1234567let A4 = &quot;haaaah&quot;;let A2 = &quot;haah&quot;;let A100 = &quot;h&quot; + &quot;a&quot;.repeat(100) + &quot;h&quot;;let multipleA = /ha{3,}h/;multipleA.test(A4);multipleA.test(A2);multipleA.test(A100); 指定匹配的确切数量 要指定一定数量的匹配模式，只需在大括号之间放置一个数字。 例如，要只匹配字母 a 出现 3 次的单词hah，正则表达式应为/ha{3}h/。 正向先行断言和负向先行断言先行断言 （Lookaheads）是告诉 JavaScript 在字符串中向前查找的匹配模式。 当想要在同一个字符串上搜寻多个匹配模式时，这可能非常有用。 有两种先行断言：正向先行断言（positive lookahead）和负向先行断言（negative lookahead）。 正向先行断言会查看并确保搜索匹配模式中的元素存在，但实际上并不匹配。 正向先行断言的用法是 (?=...)，其中 ... 就是需要存在但不会被匹配的部分。 另一方面，负向先行断言会查看并确保搜索匹配模式中的元素不存在。 负向先行断言的用法是 (?!...)，其中 ... 是希望不存在的匹配模式。 如果负向先行断言部分不存在，将返回匹配模式的其余部分。 123456let quit = &quot;qu&quot;;let noquit = &quot;qt&quot;;let quRegex= /q(?=u)/;let qRegex = /q(?!u)/;quit.match(quRegex);//[&quot;q&quot;]noquit.match(qRegex);//[&quot;q&quot;] 先行断言的更实际用途是检查一个字符串中的两个或更多匹配模式。 这里有一个简单的密码检查器，密码规则是 3 到 6 个字符且至少包含一个数字： 123let password = &quot;abc123&quot;;let checkPass = /(?=\\w{3,6})(?=\\D*\\d)/;checkPass.test(password); 检查混合字符组有时候我们想使用正则表达式里的括号 () 来检查字符组。 如果想在字符串找到 Penguin 或 Pumpkin，可以用这个正则表达式：/P(engu|umpk)in/g。 然后使用 test() 方法检查 test 字符串里面是否包含字符组。 123let testStr = &quot;Pumpkin&quot;;let testRegex = /P(engu|umpk)in/;testRegex.test(testStr); 捕获组当你想要匹配一个像下面这样多次出现的单词， 1let repeatStr = &quot;row row row your boat&quot;; 你可以使用 /row row row/。但如果你不知道重复的特定单词，怎么办？ 捕获组 可以用于找到重复的子字符串。 捕获组是通过把要捕获的正则表达式放在括号中来构建的。 在这个例子里， 目标是捕获一个包含字母数字字符的词，所以捕获组是将 \\w+ 放在括号中：/(\\w+)/。 分组匹配的子字符串被保存到一个临时的“变量”， 可以使用同一正则表达式和反斜线及捕获组的编号来访问它（例如：\\1）。 捕获组按其开头括号的位置自动编号（从左到右），从 1 开始。 下面的示例是匹配被空格隔开的两个相同单词： 123let repeatRegex = /(\\w+) \\1 \\1/;repeatRegex.test(repeatStr); // Returns truerepeatStr.match(repeatRegex); // Returns [&quot;row row row&quot;, &quot;row&quot;] 在字符串上调用 .match() 方法将返回一个数组，其中包含它\b最终匹配到的子字符串及其捕获组。 在 reRegex 中使用捕获组来匹配一个只由相同的数字重复三次组成的由空格分隔字符串。 123let repeatNum = &quot;42 42 42&quot;;let reRegex = /^(\\d+)\\s\\1\\s\\1$/; // 修改这一行let result = reRegex.test(repeatNum); 搜索或替换搜索功能是很有用的。 但是，当搜索同时也执行更改（或替换）匹配文本的操作时，搜索功能就会显得更加强大。 可以在字符串上使用 .replace() 方法来搜索并替换字符串中的文本。 .replace() 的输入首先是想要搜索的正则表达式匹配模式。 第二个参数是用于替换匹配的字符串或用于执行某些操作的函数。 123let wrongText = &quot;The sky is silver.&quot;;let silverRegex = /silver/;wrongText.replace(silverRegex, &quot;blue&quot;); replace 调用将返回字符串 The sky is blue.。 你还可以使用美元符号（$）访问替换字符串中的捕获组。 1&quot;Code Camp&quot;.replace(/(\\w+)\\s(\\w+)/, '$2 $1'); 调用 replace 将返回字符串 Camp Code。 删除开头和结尾的空白有时字符串周围存在的空白字符并不是必需的。 字符串的典型处理是删除字符串开头和结尾处的空格。 编写一个正则表达式并使用适当的字符串方法删除字符串开头和结尾的空格。 注意： String.prototype.trim() 方法在这里也可以实现同样的效果，但是你需要使用正则表达式来完成此项挑战。 123let hello = &quot; Hello, World! &quot;;let wsRegex = /^\\s+|\\s+$/g; // 修改这一行let result = hello.replace(wsRegex,&quot;&quot;); // 修改这一行 函数式编程函数式编程是一种方案简单、功能独立、对作用域外没有任何副作用的编程范式：INPUT -&gt; PROCESS -&gt; OUTPUT。 函数式编程： 1）功能独立——不依赖于程序的状态（比如可能发生变化的全局变量）； 2）纯函数——同一个输入永远能得到同一个输出； 3）有限的副作用——可以严格地限制函数外部对状态的更改。 Callbacks 是被传递到另一个函数中调用的函数。 你应该已经在其他函数中看过这个写法，例如在 filter 中，回调函数告诉 JavaScript 以什么规则过滤数组。 函数就像其他正常值一样，可以赋值给变量、传递给另一个函数，或从其它函数返回，这种函数叫做头等 first class 函数。 在 JavaScript 中，所有函数都是头等函数。 将函数为参数或返回值的函数叫做高阶 ( higher order) 函数。 当函数被传递给另一个函数或从另一个函数返回时，那些传入或返回的函数可以叫做 lambda。 函数式编程的核心原则之一是不改变任何东西。 变化会导致错误。 如果一个函数不改变传入的参数、全局变量等数据，那么它造成问题的可能性就会小很多。 前面的例子没有任何复杂的操作，但是 splice 方法改变了原始数组，导致 bug 产生。 回想一下，在函数式编程中，改变或变更叫做 mutation，这种改变的结果叫做“副作用”（side effect）。 理想情况下，函数应该是不会产生任何副作用的 pure function。 让我们尝试掌握这个原则：不要改变代码中的任何变量或对象。 123456// 全局变量let fixedValue = 4;function incrementer() { return fixedValue+1} 虽然我们没有改变全局变量值，但在没有全局变量 fixedValue 的情况下，incrementer 函数将不起作用。 函数式编程的另一个原则是：总是显式声明依赖关系。 如果函数依赖于一个变量或对象，那么将该变量或对象作为参数直接传递到函数中。 这样做会有很多好处。 其中一点是让函数更容易测试，因为你确切地知道参数是什么，并且这个参数也不依赖于程序中的任何其他内容。 其次，这样做可以让你更加自信地更改，删除或添加新代码。 因为你很清楚哪些是可以改的，哪些是不可以改的，这样你就知道哪里可能会有潜在的陷阱。 最后，无论代码的哪一部分执行它，函数总是会为同一组输入生成相同的输出。 1234567// 全局变量let fixedValue = 4;// 只修改这一行下面的代码function incrementer(param) { return param+1} 目前为止，我们已经看到了函数式编程的两个原则： 不要更改变量或对象 - 创建新变量和对象，并在需要时从函数返回它们。 提示：使用类似 const newArr = arrVar 的东西，其中 arrVar 是一个数组，只会创建对现有变量的引用，而不是副本。 所以更改 newArr 中的值会同时更改 arrVar 中的值。 声明函数参数 - 函数内的任何计算仅取决于参数，而不取决于任何全局对象或变量。 reduce方法分析数据reduce()（即Array.prototype.reduce()），是 JavaScript 所有数组操作中最常用的方法。 几乎可以用reduce方法解决所有数组处理问题。 reduce方法是处理数组更通用的方式，而且filter和map方法都可以当作是reduce的特殊实现。 reduce方法遍历数组中的每个项目并返回单个值（即字符串、数字、对象、数组）。 这是通过在每次迭代中调用一个回调函数来实现的。 回调函数接受四个参数。 第一个参数称为叠加器，它是上一次迭代中回调函数的返回值，第二个参数是当前正在处理的数组元素，第三个参数是该参数的索引，第四个参数是在其上调用 reduce 方法的数组。 除了回调函数，reduce 还有一个额外的参数做为叠加器的初始值。 如果没有第二个参数，会跳过第一次迭代，第二次迭代给叠加器传入数组的第一个元素。 见下面的例子，给 users 数组使用 reduce 方法，返回所有用户数组的和。 为了简化，例子仅使用了回调函数的第一个参数和第二个参数。 12345678const users = [ { name: 'John', age: 34 }, { name: 'Amy', age: 20 }, { name: 'camperCat', age: 10 }];const sumOfAges = users.reduce((sum, user) =&gt; sum + user.age, 0);console.log(sumOfAges); 1234567891011const users = [ { name: 'John', age: 34 }, { name: 'Amy', age: 20 }, { name: 'camperCat', age: 10 }];const usersObj = users.reduce((obj, user) =&gt; { obj[user.name] = user.age; return obj;}, {});console.log(usersObj); 12345678910111213141516171819202122232425262728293031/*watchList 是包含一些电影信息的对象。 使用 reduce 查找由 Christopher Nolan 导演的电影的 IMDB 评级平均值。 回想一下之前的挑战，如何 filter 数据，以及使用 map 来获取你想要的数据。 您可能需要创建其他变量，并从 getRating 函数返回平均评分。 请注意，评级在对象中是字符串，需要将其转换为数字再用于数学运算。*/function getRating(watchList){ // Add your code below this line const averageRating = watchList // Use filter to find films directed by Christopher Nolan .filter(film =&gt; film.Director === &quot;Christopher Nolan&quot;) // Use map to convert their ratings from strings to numbers .map(film =&gt; Number(film.imdbRating)) // Use reduce to add together their ratings .reduce((sumOfRatings, rating) =&gt; sumOfRatings + rating) / // Divide by the number of Nolan films to get the average rating watchList.filter(film =&gt; film.Director === &quot;Christopher Nolan&quot;).length; // Add your code above this line return averageRating;}function getRating(watchList) { // Add your code below this line const nolanData = watchList .reduce((data, { Director: director, imdbRating: rating }) =&gt; { if (director === 'Christopher Nolan') { data.count++; data.sum += Number(rating); } return data; }, { sum: 0, count: 0 }); const averageRating = nolanData.sum / nolanData.count; // Add your code above this line return averageRating;} sort排序sort 方法可以根据回调函数对数组元素进行排序。 举个例子： 1234567function ascendingOrder(arr) { return arr.sort(function(a, b) { return a - b; });}ascendingOrder([1, 5, 2, 3, 4]); 这将返回值 [1, 2, 3, 4, 5]。 1234567function reverseAlpha(arr) { return arr.sort(function(a, b) { return a === b ? 0 : a &lt; b ? 1 : -1; });}reverseAlpha(['l', 'h', 'z', 'b', 's']); 这将返回值 ['z', 's', 'l', 'h', 'b']。 JavaScript 的默认排序方法是 Unicode 值顺序排序，有时可能会得到意想不到的结果。 因此，建议提供一个回调函数来指定如何对数组项目排序。 这个回调函数通常叫做 compareFunction，它根据 compareFunction 的返回值决定数组元素的排序方式： 如果两个元素 a 和 b，compareFunction(a,b) 返回一个比 0 小的值，那么 a 会在 b 的前面。 如果两个元素 a 和 b，compareFunction(a,b) 返回一个比 0 大的值，那么 b 会在 a 的前面。 如果两个元素 a 和 b，compareFunction(a,b) 返回等于 0 的值，那么 a 和 b 的位置保持不变。 123456789function alphabeticalOrder(arr) { // 只修改这一行下面的代码 return arr.sort(function(a,b){ return a.charCodeAt()-b.charCodeAt() }) // 只修改这一行上面的代码}alphabeticalOrder([&quot;a&quot;, &quot;d&quot;, &quot;c&quot;, &quot;a&quot;, &quot;z&quot;, &quot;g&quot;]); sort 方法会产生改变原始数组中元素顺序的副作用。 换句话说，它会改变数组的位置。 避免这种情况的一种方法是先将空数组连接到正在排序的数组上（记住 slice 和 concat 返回一个新数组），再用sort方法。 split方法（切割字符串成数组）split 方法将一个字符串分割成一个字符串数组。 它需要一个参数作为分隔符，它可以是用于拆分字符串或正则表达式的一个字符。 举个例子，如果分隔符是空格，你会得到一个单词数组；如果分隔符是空字符串，你会得到一个由字符串中每个字符组成的数组。 下面是两个用空格分隔一个字符串的例子，另一个是用数字的正则表达式分隔： 12345const str = &quot;Hello World&quot;;const bySpace = str.split(&quot; &quot;);const otherString = &quot;How9are7you2today&quot;;const byDigits = otherString.split(/\\d/); bySpace 将有值 [&quot;Hello&quot;, &quot;World&quot;]，byDigits 将有值 [&quot;How&quot;, &quot;are&quot;, &quot;you&quot;, &quot;today&quot;]。 因为字符串是不可变的，split 方法操作它们更方便。 join方法（拼接数组字符）12const arr = [&quot;Hello&quot;, &quot;World&quot;];const str = arr.join(&quot; &quot;); every方法检查数组中每个元素是否符合条件every 方法用于检测数组中所有元素是否都符合指定条件。 如果所有元素满足条件，返回布尔值 true，反之返回 false。 举个例子，下面的代码检测数组 numbers 的所有元素是否都小于 10： 12345const numbers = [1, 5, 8, 0, 10, 11];numbers.every(function(currentValue) { return currentValue &lt; 10;}); every 方法在这里会返回 false。 some 方法检查数组中是否有元素是否符合条件some 方法用于检测数组中任何元素是否满足指定条件。 如果有一个元素满足条件，返回布尔值 true，反之返回 false。 举个例子，下面的代码检测数组numbers中是否有元素小于 10： 12345const numbers = [10, 50, 8, 220, 110, 11];numbers.some(function(currentValue) { return currentValue &lt; 10;}); some 方法将返回 true。 函数柯里化和局部调用arity（参数个数）是函数所需的形参的数量。 函数柯里化（Currying）意思是把接受多个 arity 的函数变换成接受单一 arity 的函数。 换句话说，就是重构函数让它接收一个参数，然后返回接收下一个参数的函数，依此类推。 举个例子： 12345678910111213function unCurried(x, y) { return x + y;}function curried(x) { return function(y) { return x + y; }}const curried = x =&gt; y =&gt; x + ycurried(1)(2) curried(1)(2) 会返回 3。 柯里化在不能一次为函数提供所有参数情况下很有用。 因为它可以将每个函数的调用保存到一个变量中，该变量将保存返回的函数引用，该引用在下一个参数可用时接受该参数。 下面是使用柯里化函数的例子： 12const funcForY = curried(1);console.log(funcForY(2)); // 3 类似地，局部调用（ partial application）的意思是一次对一个函数应用几个参数，然后返回另一个应用更多参数的函数。 这是一个示例： 123456function impartial(x, y, z) { return x + y + z;}const partialFn = impartial.bind(this, 1, 2);partialFn(10); // 13","link":"/2022/10/03/JavaScript%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB/"},{"title":"JavaScript学习汇总","text":"变量值数据类型 字符串 String​ 字符串是文本的一部分。当你给一个变量赋值为字符串时，你需要用单引号或者双引号把值给包起来，否则 JavaScript 将会把这个字符串值理解成别的变量名。 数组 Number​ 你可以在变量中存储数字，不论这些数字是像 30（也叫整数）这样，或者像 2.456 这样的小数（也叫做浮点数）。与其他编程语言不同，在 JavaScript 中你不需要声明一个变量的类型。当你给一个变量数字赋值时，不需要用引号括起来。 最大值为2^53，如果超出最大值，会进行取整操作 布尔 BooleanBoolean 的值有 2 种：true 或 false。它们通常被用于在适当的代码之后，测试条件是否成立。 数值类型环境中会被当作 0 来对待 布尔类型环境中会被当作false 12var n = null;console.log(n * 32); // 在控制台中会显示 0 空值 Null 未定义 Undefined 使用 undefined 来判断一个变量是否已赋值 在布尔类型环境中会被当作false 数值类型环境中会被转换为NaN 变量提升 JavaScript 变量感觉上是被“提升”或移到了函数或语句的最前面。但是，提升后的变量将返回 undefined 值。因此在使用或引用某个变量之后进行声明和初始化操作，这个被提升的变量仍将返回 undefined 值。 在 ECMAScript 6 中，let和const同样会被提升变量到代码块的顶部但是不会被赋予初始值。在变量声明之前引用这个变量，将抛出引用错误（ReferenceError）。这个变量将从代码块一开始的时候就处在一个“暂时性死区”，直到这个变量被声明为止。 12console.log(x === undefined); // truevar x = 3; 12var a;a + 2; // 计算为 NaN Symbol 引用数据类型 对象 Object​ 在编程中，对象是现实生活中的模型的一种代码结构。您可以有一个简单的对象，代表一个停车场，并包含有关其宽度和长度的信息，或者您可以有一个代表一个人的对象，并包含有关他们的名字，身高，体重，他们说什么语言，如何说 你好，他们，等等。 1let dog = { name : 'Spot', breed : 'Dalmatian' }; 数组 Array数组是一个单个对象，其中包含很多值，方括号括起来，并用逗号分隔 12let myNameArray = ['Chris', 'Bob', 'Jim'];let myNumberArray = [10,15,40]; 常见方法(75条消息) 详解split()使用方法_陈小谷谷的博客-CSDN博客_split 123let myData = 'Manchester,London,Liverpool,Birmingham,Leeds,Carlisle';let myArray = myData.split(',');//根据每个逗号分隔 函数 Function12345function functionname(var1,var2){ // 执行代码 return x} var与let的区别var可以多次声明相同名称的变量 使用 var 关键字声明变量时，它是全局声明的，如果在函数内部声明则是局部声明的。 let 关键字的行为类似，但有一些额外的功能。 在代码块、语句或表达式中使用 let 关键字声明变量时，其作用域仅限于该代码块、语句或表达式。 123456789101112var numArray = [];for (var i = 0; i &lt; 3; i++) { numArray.push(i);}console.log(numArray);//[0, 1, 2]console.log(i);//3//for (let i = 0; i &lt; 3; i++) { numArray.push(i);}console.log(numArray);//[0, 1, 2]console.lg(i);//未被定义 12var myName = 'Chris';var myName = 'Bob'; let不能多次声明相同名称的变量 12let myName = 'Chris';let myName = 'Bob'; const默认情况下，一些开发人员更喜欢使用 const 分配所有变量，除非他们知道需要重新分配值。 只有在这种情况下，他们才使用 let。 但是，重要的是要了解使用 const 分配给变量的对象（包括数组和函数）仍然是可变的。 使用 const 声明只能防止变量标识符的重新分配。 1234const s = [5, 6, 7];s = [1, 2, 3];//s = [1, 2, 3] 将导致错误。s[2] = 45;console.log(s);//console.log 将显示值 [5, 6, 45]。 const 声明并不会真的保护数据不被改变。 为了确保数据不被改变，JavaScript 提供了一个函数 Object.freeze。 任何更改对象的尝试都将被拒绝，如果脚本在严格模式下运行，将抛出错误。 12345678let obj = { name:&quot;FreeCodeCamp&quot;, review:&quot;Awesome&quot;};Object.freeze(obj);obj.review = &quot;bad&quot;;//错误obj.newProp = &quot;Test&quot;;//错误console.log(obj); 命名规则 你不应当使用规则之外的其他字符，因为它们可能引发错误，或对国际用户来说难以理解。 变量名不要以下划线开头—— 以下划线开头的被某些 JavaScript 设计为特殊的含义，因此可能让人迷惑。 变量名不要以数字开头。这种行为是不被允许的，并且将引发一个错误。 一个可靠的命名约定叫做 “小写驼峰命名法”，用来将多个单词组在一起，小写整个命名的第一个字母然后大写剩下单词的首字符。我们已经在文章中使用了这种命名方法。（myName） 让变量名直观，它们描述了所包含的数据。不要只使用单一的字母/数字，或者长句。 变量名大小写敏感——因此myage与myAge是 2 个不同的变量。 最后也是最重要的一点—— 你应当避免使用 JavaScript 的保留字给变量命名。保留字，即是组成 JavaScript 的实际语法的单词！因此诸如 var, function, let和 for等，都不能被作为变量名使用。浏览器将把它们识别为不同的代码项，因此你将得到错误。 函数apply(90条消息) Js apply方法详解,及其apply()方法的妙用_lixiaotao_1的博客-CSDN博客_apply的参数 劫持另外一个对象的方法，继承另外一个对象的属性 如果 apply() 方法的第一个参数不是对象，则它将成为被调用函数的所有者（对象）。在“非严格”模式下，它成为全局对象。 123456789101112131415161718//Function.apply(obj,args)var person = { fullName: function(city, country) { return this.firstName + &quot; &quot; + this.lastName + &quot;,&quot; + city + &quot;,&quot; + country; }}var person1 = { firstName:&quot;Bill&quot;, lastName: &quot;Gates&quot;}//person使用apply劫持了person1的属性，替代了person中this对象person.fullName.call(person1, [&quot;Oslo&quot;, &quot;Norway&quot;]); // 将返回 &quot;Bill Gates,Seatle,USA&quot;person.fullName.call(person1, &quot;Oslo&quot;, &quot;Norway&quot;); // 将返回 &quot;Bill Gates,Seatle,USA&quot;//求数组最大值var array = [1, 2, 3];var max = Math.max.apply(null, array);console.log(max);//3 callcall 方法的语法和作用与 apply() 方法类似，只有一个区别，就是 call() 方法接受的是一个参数列表，而 apply() 方法接受的是一个包含多个参数的 **数组**。 123456789101112//function.call(thisArg, arg1, arg2, ...);var person = { fullName: function(city, country) { return this.firstName + &quot; &quot; + this.lastName + &quot;,&quot; + city + &quot;,&quot; + country; }}var person1 = { firstName:&quot;Bill&quot;, lastName: &quot;Gates&quot;}person.fullName.call(person1, &quot;Seattle&quot;, &quot;USA&quot;); 闭包彻底理解js闭包 - 知乎 (zhihu.com)（有一道面试题） 闭包 - JavaScript | MDN (mozilla.org) 有权访问另一个函数作用域中的变量的函数；一般情况就是在一个函数中包含另一个函数。 闭包的实现原理，其实是利用了作用域链的特性，我们都知道作用域链就是在当前执行环境下访问某个变量时，如果不存在就一直向外层寻找，最终寻找到最外层也就是全局作用域，这样就形成了一个链条。 作用1：隐藏变量，避免全局污染 作用2：可以读取函数内部的变量 函数创建和函数执行不在同一个作用域下就会形成闭包。 闭包是指那些能够访问自由变量的函数（自由变量：是指在函数中使用的变量即不是函数参数arguments也不是函数内部声明的变量，那这个变量就是自由变量。） 闭包是指有权访问另外一个函数作用域中的变量的函 12345678910111213141516171819202122232425262728293031323334//1、通过全局变量，可以实现，但会污染其他程序var a = 10;function Add(){ a++; console.log(a);}Add();Add();Add();//2、定义一个局部变量，不污染全局，但是实现不了递增var a = 10;function Add2(){ var a = 10; a++; console.log(a);}Add2();Add2();Add2();console.log(a);//3、通过闭包，可以是函数内部局部变量递增，不会影响全部变量var a = 10;function Add3(){ var a = 10; return function(){ a++; return a; };};var cc = Add3();console.log(cc());console.log(cc());console.log(cc());console.log(a); callback回调函数可以将一个函数当作另一个函数的形参来传递。格式如下： 123function A (形参1, 形参2, 函数B) { do something;} 其实你可以先声明一个function 函数B ()这样子的，又可以在调用的时候才去实现这个方法。 12345function A (形参1, 形参2, 函数B) { do something;}A(传入形参1, 传入形参2, 函数B() { 这里是函数B的实现方法体}) 1234567891011121314// 全局变量const s = [23, 65, 98, 5];Array.prototype.myMap = function(callback) { const newArray = []; // 只修改这一行下面的代码 this.forEach(a =&gt; newArray.push(callback(a))); // 只修改这一行上面的代码 return newArray;};const new_s = s.myMap(function(item) { return item * 2;}); 作用回调函数是NodeJs中异步编程很重要的一个知识。例如，我们可以一边读取文件，一边执行其他命令，在文件读取完成后，我们将文件内容作为回调函数的参数返回。这样在执行代码时就没有阻塞或等待文件 I/O 操作。这就大大提高了 Node.js 的性能，可以处理大量的并发请求。 举例123456789101112131415161718192021function add (x, y) { // 设置1秒后出计算结果 console.log('开始运算') setTimeout (function () { // 保存计算结果 console.log('保存计算结果') var result = x + y return result }, 1000) console.log('结束运算')}// 打印返回值结果console.log('计算结果为：'+add(1, 2))//运行结果/*开始运算结束运算计算结果为undefined保存计算结果*/ undefined ？为什么会是这个结果？ 从执行顺序上来看我们就可以得出结论， 打印返回值结果 这一步并没有等待到 setTimeout 里面相加这步运行结束就已经打印结果了 ，所以返回结果为undefined。 我们要做的就是得到setTimeout里面的返回值。 我们来用callback函数改写一下上面的案例 123456789101112131415161718192021222324function add (x, y, callback) { // 设置1秒后出计算结果 console.log('开始运算') setTimeout (function () { // 保存计算结果 console.log('保存计算结果') var result = x + y callback(result) }, 1000) console.log('结束运算')}add(1, 2, function (result) { // 这是callback函数实现体 console.log('计算结果为：'+result)})//运算结果/*开始运算结束运算保存计算结果计算结果为：3*/ 这个函数的执行流程就是：传入x, y -&gt; add跳过等待 -&gt; add执行结束 -&gt;setTimeout开始计算结果 -&gt; 将计算结果当作callback函数的参数 -&gt; callback函数实现体。 作用就是将异步的计算结果当作另一个函数的形参转发出去了。相当于你写多一个方法来保存这个计算结果。 创建新对象使用对象初始化器123456var obj = { property_1: value_1, // property_# 可以是一个标识符... 2: value_2, // 或一个数字... [&quot;property&quot; +3]: value_3, // 或一个可计算的 key 名... // ..., &quot;property n&quot;: value_n }; // 或一个字符串 下面的语句只有当 cond 表达式的值为 true 时创建对象并将其赋给变量 x。 1if (cond) var x = {hi: &quot;there&quot;}; 下例创建了有三个属性的 myHonda 对象。注意它的 engine 属性也是一个拥有自己属性的对象。 1var myHonda = {color: &quot;red&quot;, wheels: 4, engine: {cylinders: 4, size: 2.2}}; 使用构造函数new123456function Car(make, model, year) { this.make = make; this.model = model; this.year = year;}var mycar = new Car(&quot;Eagle&quot;, &quot;Talon TSi&quot;, 1993); 首先创建一个空对象 设置原型，将对象的_proto_纸箱构造函数的protype对象 让函数的this指向这个对象，执行构造函数的代码（为这个新对象添加属性） 判断函数的返回类型，如果是值类型，返回创建的对象。如果是引用型对象，则返回这个引用类型的对象 使用Object.create方法12345678910111213141516// Animal properties and method encapsulationvar Animal = { type: &quot;Invertebrates&quot;, // 属性默认值 displayType : function() { // 用于显示 type 属性的方法 console.log(this.type); }}// 创建一种新的动物——animal1var animal1 = Object.create(Animal);animal1.displayType(); // Output:Invertebrates// 创建一种新的动物——Fishesvar fish = Object.create(Animal);fish.type = &quot;Fishes&quot;;fish.displayType(); // Output:Fishes Object.create(Obj)的内部，并没有去调用Obj构造函数，而是调用了创建新对象的构造函数，因此Obj上的属性不会继承到Object.create创建的实例中 Object.create(Obj)会凭空创建一个“新”对象并把新对象内部的[[Prototype]]关联到你指定的对象 继承所有的 JavaScript 对象至少继承于一个对象。被继承的对象被称作原型，并且继承的属性可通过构造函数的 prototype 对象找到。 在 JavaScript 1.0 中，你可以通过名称或序号访问一个属性。但是在 JavaScript 1.1 及之后版本中，如果你最初使用名称定义了一个属性，则你必须通过名称来访问它；而如果你最初使用序号来定义一个属性，则你必须通过索引来访问它。 这个限制发生在你通过构造函数创建一个对象和它的属性（就象我们之前通过 Car 对象类型所做的那样）并且显式地定义了单独的属性（如 myCar.color = “red”）之时。如果你最初使用索引定义了一个对象属性，例如 myCar[5] = &quot;25&quot;，则你只可能通过 myCar[5] 引用它。 你可以通过 prototype 属性为之前定义的对象类型增加属性。这为该类型的所有对象，而不是仅仅一个对象增加了一个属性。下面的代码为所有类型为 car 的对象增加了 color 属性，然后为对象 car1 的 color 属性赋值： 12Car.prototype.color = null;car1.color = &quot;black&quot;; 通过this引用对象JavaScript 有一个特殊的关键字 this，它可以在方法中使用以指代当前对象。 12&lt;input type=&quot;text&quot; name=&quot;age&quot; size=&quot;3&quot; onChange=&quot;validate(this, 18, 99)&quot;&gt; 当与 form 属性一起使用时，this 可以指代当前对象的父窗体。在下面的例子中，窗体 myForm 包含一个 Text 对象和一个按钮，当用户点击按键，Text 对象的值被设为窗体的名称。按钮的 onclick 事件处理器使用 this.form 以指代其父窗体，即 myForm。 123456&lt;form name=&quot;myForm&quot;&gt;&lt;p&gt;&lt;label&gt;Form name:&lt;input type=&quot;text&quot; name=&quot;text1&quot; value=&quot;Beluga&quot;&gt;&lt;/label&gt;&lt;p&gt;&lt;input name=&quot;button1&quot; type=&quot;button&quot; value=&quot;Show Form Name&quot; onclick=&quot;this.form.text1.value = this.form.name&quot;&gt;&lt;/p&gt;&lt;/form&gt; 定义getters与setters一个 getter 是一个获取某个特定属性的值的方法。一个 setter 是一个设定某个属性的值的方法。你可以为预定义的或用户定义的对象定义 getter 和 setter 以支持新增的属性。定义 getter 和 setter 的语法采用对象字面量语法。 123456789101112131415161718192021//使用使用 使用对象初始化器 定义var o = { a: 7, get b() { return this.a + 1; }, set c(x) { this.a = x / 2 }};//使用 getter 和 setter 添加方法添加到任何对象var o = { a:0 }Object.defineProperties(o, { &quot;b&quot;: { get: function () { return this.a + 1; } }, &quot;c&quot;: { set: function (x) { this.a = x / 2; } }});console.log(o.a); // 7console.log(o.b); // 8o.c = 50;console.log(o.a); // 25 下面这个例子展示使用 getter 和 setter 方法扩展 Date原型，为预定义好的 Date 类添加一个 year 的属性。定义属性 year 的 getter 和 setter 方法用到了 Date 类中已存在的 getFullYear 和 setFullYear 方法。 定义属性 year 的 getter 和 setter： 12345var d = Date.prototype;Object.defineProperty(d, &quot;year&quot;, { get: function() { return this.getFullYear() }, set: function(y) { this.setFullYear(y) }}); 删除属性你可以用 delete 操作符删除一个不是继承而来的属性。下面的例子说明如何删除一个属性： 12345678//Creates a new object, myobj, with two properties, a and b.var myobj = new Object;myobj.a = 5;myobj.b = 12;//Removes the a property, leaving myobj with only the b property.delete myobj.a; 如果一个全局变量不是用 var 关键字声明的话，你也可以用 delete 删除它： 12g = 17;delete g; 比较对象在 JavaScript 中 objects 是一种引用类型。两个独立声明的对象永远也不会相等，即使他们有相同的属性，只有在比较一个对象和这个对象的引用时，才会返回 true. 123456// 两个变量，两个具有同样的属性、但不相同的对象var fruit = {name: &quot;apple&quot;};var fruitbear = {name: &quot;apple&quot;};fruit == fruitbear // return falsefruit === fruitbear // return false 验证对象的构造函数凡是通过构造函数创建出的新对象，这个对象都叫做这个构造函数的 实例。 JavaScript 提供了一种很简便的方法来验证这个事实，那就是通过 instanceof 操作符。 instanceof 允许你将对象与构造函数之间进行比较，根据对象是否由这个构造函数创建的返回 true 或者 false。 以下是一个示例： 123456789let Bird = function(name, color) { this.name = name; this.color = color; this.numLegs = 2;}let crow = new Bird(&quot;Alexis&quot;, &quot;black&quot;);//instanceof 方法会返回 true.crow instanceof Bird; 自身属性与prototype自身属性和 prototype 属性。 自身属性是直接在对象上定义的。 而原型属性在 prototype 上定义。 1234567function Bird(name) { this.name = name; //own property}Bird.prototype.numLegs = 2; // prototype propertylet duck = new Bird(&quot;Donald&quot;); 立即调用函数表达IIFEJavaScript 中的一个常见模式就是，函数在声明后立刻执行： 123(function () { console.log(&quot;Chirp, chirp!&quot;);})(); 这是一个匿名函数表达式，立即执行并输出 Chirp, chirp!。 请注意，函数没有名称，也不存储在变量中。 函数表达式末尾的两个括号（）会让它被立即执行或调用。 这种模式被叫做立即调用函数表达式（immediately invoked function expression) 或者IIFE。 使用 IIFE 创建一个模块一个立即调用函数表达式（IIFE）通常用于将相关功能分组到单个对象或者是 module 中。 例如，先前的挑战中定义了两个 mixins： 12345678910function glideMixin(obj) { obj.glide = function() { console.log(&quot;Gliding on the water&quot;); };}function flyMixin(obj) { obj.fly = function() { console.log(&quot;Flying, wooosh!&quot;); };} 我们可以将这些 mixins 分成以下模块： 1234567891011121314let motionModule = (function () { return { glideMixin: function(obj) { obj.glide = function() { console.log(&quot;Gliding on the water&quot;); }; }, flyMixin: function(obj) { obj.fly = function() { console.log(&quot;Flying, wooosh!&quot;); }; } }})(); 注意：一个立即调用函数表达式（IIFE）返回了一个 motionModule 对象。 返回的这个对象包含了作为对象属性的所有 mixin 行为。 module 模式的优点是，所有的运动相关的行为都可以打包成一个对象，然后由代码的其他部分使用。 下面是一个使用它的例子： 12motionModule.glideMixin(duck);duck.glide(); 对象模型的细节对象模型的细节 - JavaScript | MDN (mozilla.org) 基于类的（Java） 基于原型的（JavaScript） 类和实例是不同的事物。 所有对象均为实例。 通过类定义来定义类；通过构造器方法来实例化类。 通过构造器函数来定义和创建一组对象。 通过 new 操作符创建单个对象。 相同。 通过类定义来定义现存类的子类，从而构建对象的层级结构。 指定一个对象作为原型并且与构造函数一起构建对象的层级结构 遵循类链继承属性。 遵循原型链继承属性。 类定义指定类的所有实例的所有属性。无法在运行时动态添加属性。 构造器函数或原型指定实例的初始属性集。允许动态地向单个的对象或者整个对象集中添加或移除属性。 创建层级结构 12345678910111213141516171819202122232425262728function Employee () { this.name = &quot;&quot;; this.dept = &quot;general&quot;;}function Manager() { Employee.call(this);//继承Employee this.reports = [];}Manager.prototype = Object.create(Employee.prototype);function WorkerBee() { Employee.call(this);//继承Employee this.projects = [];}WorkerBee.prototype = Object.create(Employee.prototype);function SalesPerson() { WorkerBee.call(this);//继承WorkerBee this.dept = 'sales'; this.quota = 100;}SalesPerson.prototype = Object.create(WorkerBee.prototype);function Engineer() { WorkerBee.call(this);//继承WorkerBee this.dept = 'engineering'; this.machine = '';}Engineer.prototype = Object.create(WorkerBee.prototype); 继承属性假设您通过如下语句创建一个mark对象作为 WorkerBee的实例： 1var mark = new WorkerBee; 当 JavaScript 执行 new 操作符时，它会先创建一个普通对象，并将这个普通对象中的 [[prototype]] 指向 WorkerBee.prototype ，然后再把这个普通对象设置为执行 WorkerBee 构造函数时 this 的值。该普通对象的 [[Prototype]] 决定其用于检索属性的原型链。当构造函数执行完成后，所有的属性都被设置完毕，JavaScript 返回之前创建的对象，通过赋值语句将它的引用赋值给变量 mark。 这个过程不会显式的将 mark所继承的原型链中的属性作为本地属性存放在 mark 对象中。当访问属性时，JavaScript 将首先检查对象自身中是否存在该属性，如果有，则返回该属性的值。如果不存在，JavaScript 会检查原型链（使用内置的 [[Prototype]] ）。如果原型链中的某个对象包含该属性，则返回这个属性的值。如果遍历整条原型链都没有找到该属性，JavaScript 则认为对象中不存在该属性，返回一个 undefined。这样，mark 对象中将具有如下的属性和对应的值： 123mark.name = &quot;&quot;;mark.dept = &quot;general&quot;;mark.projects = []; mark 对象从 mark.__proto__ 中保存的原型对象里继承了 name 和 dept 属性。并由 WorkerBee 构造函数为 projects 属性设置了本地值。 1this.name = name || &quot;&quot;; JavaScript 的逻辑或操作符（||）会对第一个参数进行判断。如果该参数值运算后结果为真，则操作符返回该值。否则，操作符返回第二个参数的值。因此，这行代码首先检查 name 是否是对name 属性有效的值。如果是，则设置其为 this.name 的值。否则，设置 this.name 的值为空的字符串。 原型链「每日一题」什么是 JS 原型链？ - 知乎 (zhihu.com) (77条消息) JS原型对象和对象原型的区别_Hevttc_Cao的博客-CSDN博客_原型对象和对象原型的区别 (77条消息) 详解JS原型与原型链_小杰学前端的博客-CSDN博客_js原型和原型链 每个对象都可以有一个原型_proto_，这个原型还可以有它自己的原型，以此类推，形成一个原型链。查找特定属性的时候，我们先去这个对象里去找，如果没有的话就去它的原型对象里面去，如果还是没有的话再去向原型对象的原型对象里去寻找…… 这个操作被委托在整个原型链上，这个就是我们说的原型链了。 ​ 原型指针prototype: prototype属性，它是函数所独有的，它是从一个函数指向一个对象。它的含义是函数的原型对象，也就是这个函数（其实所有函数都可以作为构造函数）所创建的实例的原型对象; 这个属性是一个指针，指向一个对象，这个对象的用途就是包含所有实例共享的属性和方法（我们把这个对象叫做原型对象）; JavaScript规定,每一个构造函数都有一个prototype属性, 指向另一个对象。注意这个prototype就是一个对象,这个对象的所有属性和方法,都会被构造函数所拥有。 我们可以把那些不变的方法,直接定义在prototype对象上,这样所有对象的实例就可以共享这些方法。 _proto_: proto 是原型链查询中实际用到的，它总是指向 prototype，换句话说就是指向构造函数的原型对象，它是对象独有的。注意，为什么Foo构造也有这个属性呢，因为再js的宇宙里万物皆对象，包括函数； 对象都会有一个属性_ proto_指向构造函数的 prototype原型对象,之所以我们对象可以使用构造函数prototype原型对象的属性和方法,就是因为对象有_proto_ 原型的存在。 带键的集合123456789101112131415161718var sayings = new Map();sayings.set('dog', 'woof');sayings.set('cat', 'meow');sayings.set('elephant', 'toot');sayings.size; // 3sayings.get('fox'); // undefinedsayings.has('bird'); // falsesayings.delete('dog');sayings.has('dog'); // falsefor (var [key, value] of sayings) { console.log(key + ' goes ' + value);}// &quot;cat goes meow&quot;// &quot;elephant goes toot&quot;sayings.clear();sayings.size; // 0 Map函数12345678910111213141516const users = [ { name: 'John', age: 34 }, { name: 'Amy', age: 20 }, { name: 'camperCat', age: 10 }];const names = users.map(user=&gt;{ return{ &quot;name&quot;:user.name, &quot;age&quot;:user.age }})const names = users.map(user =&gt; user.name);console.log(names); Map与Object比较一般地，objects会被用于将字符串类型映射到数值。Object允许设置键值对、根据键获取值、删除键、检测某个键是否存在。而Map具有更多的优势。 Object的键均为Strings类型，在Map里键可以是任意类型。 必须手动计算Object的尺寸，但是可以很容易地获取使用Map的尺寸。 Map的遍历遵循元素的插入顺序。 Object有原型，所以映射中有一些缺省的键。（可以用 map = Object.create(null) 回避）。 这三条提示可以帮你决定用Map还是Object： 如果键在运行时才能知道，或者所有的键类型相同，所有的值类型相同，那就使用Map。 如果需要将原始值存储为键，则使用Map，因为Object将每个键视为字符串，不管它是一个数字值、布尔值还是任何其他原始值。 如果需要对个别元素进行操作，使用Object。 WeakMap对象WeakMap对象也是键值对的集合。它的键必须是对象类型，值可以是任意类型。它的键被弱保持，也就是说，当其键所指对象没有其他地方引用的时候，它会被 GC 回收掉。WeakMap提供的接口与Map相同。 与Map对象不同的是，WeakMap的键是不可枚举的。不提供列出其键的方法。列表是否存在取决于垃圾回收器的状态，是不可预知的。 对象内部的私有数据和方法被存储在WeakMap类型的privates变量中。所有暴露出的原型和情况都是公开的，而其他内容都是外界不可访问的，因为模块并未导出privates对象。 123456789101112131415const privates = new WeakMap();function Public() { const me = { // Private data goes here }; privates.set(this, me);}Public.prototype.method = function () { const me = privates.get(this); // Do stuff with private data in `me`...};module.exports = Public; 集合Set对象Set对象是一组值的集合，这些值是不重复的，可以按照添加顺序来遍历。 123456789101112var mySet = new Set();mySet.add(1);mySet.add(&quot;some text&quot;);mySet.add(&quot;foo&quot;);mySet.has(1); // truemySet.delete(&quot;foo&quot;);mySet.size; // 2for (let item of mySet) console.log(item);// 1// &quot;some text&quot; 数组与集合之间转换可以使用Array.from或展开操作符来完成集合到数组的转换。同样，Set的构造器接受数组作为参数，可以完成从Array到Set的转换。需要重申的是，Set对象中的值不重复，所以数组转换为集合时，所有重复值将会被删除。 1234Array.from(mySet);[...mySet2];mySet2 = new Set([1,2,3,4]); Array和Set的对比 数组中用于判断元素是否存在的indexOf 函数效率低下。 Set对象允许根据值删除元素，而数组中必须使用基于下标的 splice 方法。 数组的indexOf方法无法找到NaN值。 Set对象存储不重复的值，所以不需要手动处理包含重复值的情况。 WeakSet对象与Set对象的主要区别有： WeakSets中的值必须是对象类型，不可以是别的类型 WeakSet的“weak”指的是，对集合中的对象，如果不存在其他引用，那么该对象将可被垃圾回收。于是不存在一个当前可用对象组成的列表，所以WeakSets不可枚举 WeakSet的用例很有限，比如使用 DOM 元素作为键来追踪它们而不必担心内存泄漏。 错误处理你可以用 throw 语句抛出一个异常并且用 try...catch 语句捕获处理它。 catch 块你可以使用catch块来处理所有可能在try块中产生的异常。 finally块finally块包含了在 try 和 catch 块完成后、下面接着 try…catch 的语句之前执行的语句。finally块无论是否抛出异常都会执行。如果抛出了一个异常，就算没有异常处理，finally块里的语句也会执行。 12345678openMyFile();try { writeMyFile(theData); //This may throw a error}catch(e){ handleError(e); // If we got a error we handle it}finally { closeMyFile(); // always close the resource} 123456789101112131415161718function getMonthName(mo) { mo = mo - 1; // Adjust month number for array index (1 = Jan, 12 = Dec) var months = [&quot;Jan&quot;,&quot;Feb&quot;,&quot;Mar&quot;,&quot;Apr&quot;,&quot;May&quot;,&quot;Jun&quot;,&quot;Jul&quot;, &quot;Aug&quot;,&quot;Sep&quot;,&quot;Oct&quot;,&quot;Nov&quot;,&quot;Dec&quot;]; if (months[mo]) { return months[mo]; } else { throw &quot;InvalidMonthNo&quot;; //throw keyword is used here }}try { // statements to try monthName = getMonthName(myMonth); // function could throw exception}catch (e) { monthName = &quot;unknown&quot;; logMyErrors(e); // pass exception object to error handler -&gt; yor own function} 作用域（作用域链）作用域是在程序运行时代码中的某些特定部分中变量、函数和对象的可访问性。 (77条消息) 深入理解JS作用域和作用域链_码上十七的博客-CSDN博客_js作用域链的理解 (77条消息) JS 作用域和作用域链_destinytaoer的博客-CSDN博客_js作用域和作用域链 BOMJS BOM（浏览器对象模型） (biancheng.net) DOMDOM 概述 - Web API 接口参考 | MDN (mozilla.org) JSON JavaScript 类型 JSON 的不同点 对象和数组 属性名称必须是双引号括起来的字符串；最后一个属性后不能有逗号。 数值 禁止出现前导零（ JSON.stringify 方法自动忽略前导零，而在 JSON.parse 方法中将会抛出 SyntaxError）；如果有小数点，则后面至少跟着一位数字。 字符串 只有有限的一些字符可能会被转义；禁止某些控制字符； Unicode 行分隔符（U+2028）和段分隔符（U+2029）被允许 ; 字符串必须用双引号括起来。请参考下面的示例，可以看到 JSON.parse() 能够正常解析，但将其当作 JavaScript 解析时会抛出 SyntaxError 错误：let code = '&quot;\\u2028\\u2029&quot;'; JSON.parse(code); // 正常 eval(code); // 错误 在JSONNumber（数字内部不允许包含空格）或JSONString（字符串内部的空格被解释为相应的字符，否则就有问题了）之外的任何位置可以有多余的空白字符。JSON 只支持这些空白字符： 制表符（U+0009），回车（U+000D），换行（U+000A）以及空格（U+0020）。 JSON.parse() 解析 JSON 字符串并返回对应的值，可以额外传入一个转换函数，用来将生成的值和其属性，在返回之前进行某些修改。 JSON.stringify() 返回与指定值对应的 JSON 字符串，可以通过额外的参数，控制仅包含某些属性，或者以自定义方法来替换某些 key 对应的属性值。 AJAXAJAX 是异步的 JavaScript 和 XML（Asynchronous JavaScript And XML）。简单点说，就是使用 XMLHttpRequest 对象与服务器通信。 它可以使用 JSON，XML，HTML 和 text 文本等格式发送和接收数据。AJAX 最吸引人的就是它的“异步”特性，也就是说它可以在不重新刷新页面的情况下与服务器通信，交换数据，或更新页面。 你可以使用 AJAX 最主要的两个特性做下列事： 在不重新加载页面的情况下发送请求给服务器。 接受并使用从服务器发来的数据。 Step1——发送http请求创建一个包含必要函数功能的对象实例（XMLHttpRequest） 12345// 创建XMLHttp 实例if (window.XMLHttpRequest) { // Mozilla, Safari, IE7+ ... httpRequest = new XMLHttpRequest();} else if (window.ActiveXObject) { // IE 6 and older httpRequest = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;); 发送请求后会收到响因，此时需要告知 XMLHttp 请求对象是由哪一个 JavaScript 函数处理响应，在设置了对象的 onreadystatechange 属性后给他命名，当请求状态改变时调用函数。 1httpRequest.onreadystatechange = nameOfTheFunction; 要注意的是，函数名后没有参数，因为你把一个引用赋值给了函数，而不是真正的调用了它。 此外，如果不使用函数名的方式，你还可以用 JavaScript 的匿名函数响应处理的动作，就像下面这样： 123httpRequest.onreadystatechange = function(){ // Process the server response here.}; 接下来，声明当你接到响应后要做什么，你要发送一个实际的请求，通过调用 HTTP 请求对象的 open() 和 send() 方法，像下面这样： 12httpRequest.open('GET', 'http://www.example.org/some.file', true);httpRequest.send(); open() 的第一个参数是 HTTP 请求方法 - 有 GET，POST，HEAD 以及服务器支持的其他方法。 保证这些方法一定要是大写字母，否则其他一些浏览器（比如 FireFox）可能无法处理这个请求。更多关于 HTTP 的请求方法，可以查看 W3C specs。 第二个参数是你要发送的 URL。由于安全原因，默认不能调用第三方 URL 域名。 确保你在页面中使用的是正确的域名，否则在调用 open() 方法是会有 “permission denied” 错误提示。一个容易犯的错误是你企图通过 domain.tld 访问网站， 而不是使用 www.domain.tld。如果你真的需要向另一个域名发送请求，可以查看 HTTP access control。 第三个参数是可选的，用于设置请求是否是异步的。如果设为 true (默认值)，即开启异步，JavaScript 就不会在此语句阻塞，使得用户能在服务器还没有响应的情况下与页面进行交互。 send() 方法的参数可以是任何你想发送给服务器的内容，如果是 POST 请求的话。发送表单数据时应该用服务器可以解析的格式，像查询语句： 1&quot;name=value&amp;anothername=&quot;+encodeURIComponent(myVar)+&quot;&amp;so=on&quot; 如果你使用 POST 数据，那就需要设置请求的 MIME 类型。比如，在调用 send() 方法获取表单数据前要有下面这个： 1httpRequest.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded'); Step2——处理服务器响因在发送请求时，你提供的 JavaScript 函数名负责处理响应： 1httpRequest.onreadystatechange = nameOfTheFunction; 这个函数应该做什么？首先，函数要检查请求的状态。如果状态的值是 XMLHttpRequest.DONE （对应的值是 4），意味着服务器响应收到了并且是没问题的，然后就可以继续执行。 12345if (httpRequest.readyState === XMLHttpRequest.DONE) { // Everything is good, the response was received.} else { // Not ready yet.} 全部 readyState 状态值都在 XMLHTTPRequest.readyState，如下也是： 0 (未初始化) or (请求还未初始化) 1 (正在加载) or (已建立****服务器链接) 2 (加载成功) or (请求已接受) 3 (交互) or (正在处理请求) 4 (完成) or (请求已完成并且响应已准备好) 接下来，点击 HTTP 响应的 response code。 可能的响应码都已经列在 W3C这个列表里。在下面的例子中，我们通过检查响应码 200 OK 判断 AJAX 有没有成功。 1234567if (httpRequest.status === 200) { // Perfect!} else { // There was a problem with the request. // For example, the response may have a 404 (Not Found) // or 500 (Internal Server Error) response code.} 在检查完请求状态和 HTTP 响应码后， 你就可以用服务器返回的数据做任何你想做的了。你有两个方法去访问这些数据： httpRequest.responseText – 服务器以文本字符的形式返回 httpRequest.responseXML – 以 XMLDocument 对象方式返回，之后就可以使用 JavaScript 来处理 注意上面这一步只在你发起异步请求时有效（即 open() 的第三个参数未特别指定或设为 true）。如果你你发起的是同步请求则不必使用函数，但是非常不推荐这样子做，它的用户体验很糟糕。 Step3——简单的http请求这个 JavaScript 会请求一个 HTML 文档 test.html，包含 “I’m a test” 内容。然后我们 alert() 响应的内容。注意这个例子我们只是用了 JavaScript，没有用 jQuery。而且，HTML，XML 和 PHP 文件都要放在用一个目录下。 123456789101112131415161718192021222324252627282930&lt;button id=&quot;ajaxButton&quot; type=&quot;button&quot;&gt;Make a request&lt;/button&gt;&lt;script&gt;(function() { var httpRequest; document.getElementById(&quot;ajaxButton&quot;).addEventListener('click', makeRequest); function makeRequest() { httpRequest = new XMLHttpRequest(); if (!httpRequest) { alert('Giving up :( Cannot create an XMLHTTP instance'); return false; } httpRequest.onreadystatechange = alertContents; httpRequest.open('GET', 'test.html'); httpRequest.send(); } function alertContents() { if (httpRequest.readyState === XMLHttpRequest.DONE) { if (httpRequest.status === 200) { alert(httpRequest.responseText); } else { alert('There was a problem with the request.'); } } }})();&lt;/script&gt; 用户点击 “Make a request” 按钮； 事件处理调用 makeRequest() 函数； 请求已通过然后（onreadystatechange）传给 alertContents() 执行。 alertContents() 检查返回的响应是否 OK，然后 alert() test.html 文件内容。 Note: 如果你向一个代码片段发送请求，将返回 XML，而不是静态 XML 文件，在 IE 浏览器上则必须要设置响应头才能正常工作。如果不设置响应头为 Content-Type:application/xml ，IE 浏览器会在你访问 XML 元素时抛出 “Object Expected” 错误。 Note 2: 如果不设置响应头 Cache-Control: no-cache 浏览器将会把响应缓存下来而且再也无法重新提交请求。你也可以添加一个总是不同的 GET 参数，比如时间戳或者随机数 (详情见 bypassing the cache) Note 3: 如果变量 httpRequest 在全局范围内使用，它会在 makeRequest() 函数中被相互覆盖，从而导致资源竞争。为了避免这个情况，请在包含 AJAX 函数的闭包中声明 httpRequest 变量。 在通信错误的事件中（例如服务器宕机），在访问响应状态 onreadystatechange 方法中会抛出一个例外。为了缓和这种情况，则可以使用 try...catch 把 if...then 语句包裹起来。 1234567891011121314function alertContents() { try { if (httpRequest.readyState === XMLHttpRequest.DONE) { if (httpRequest.status === 200) { alert(httpRequest.responseText); } else { alert('There was a problem with the request.'); } } } catch( e ) { alert('Caught Exception: ' + e.description); }} Step4——处理XML响因在上一个例子中，在收到 HTTP 请求的响应后我们会请求对象的 responseText 属性，包含 test.html 文件的内容。现在我们试试 responseXML 属性。 首先，我们创建一个稍后将要请求的有效的 XML 文档。文档（test.html）包含以下内容： 1234&lt;?xml version=&quot;1.0&quot; ?&gt;&lt;root&gt; I'm a test.&lt;/root&gt; 在脚本里我们只需要把请求行改为： 123...onclick=&quot;makeRequest('test.xml')&quot;&gt;... 然后在 alertContents() 里，我们把 alert(httpRequest.responseText) 改为： 123var xmldoc = httpRequest.responseXML;var root_node = xmldoc.getElementsByTagName('root').item(0);alert(root_node.firstChild.data); 这部分代码采用 responseXML 提供的 XMLDocument 对象，并使用 DOM 方法访问 XML 文档中包含的一些数据。你可以在这里查看 test.xml 并且在这里更新测试代码。 HTTP请求报文ES6在 JavaScript 里，我们会经常遇到不需要给函数命名的情况，尤其是在需要将一个函数作为参数传给另外一个函数的时候。 这时，我们会创建匿名函数。 因为这些函数不会在其他地方复用，所以我们不需要给它们命名。 这种情况下，我们通常会使用以下语法： 1234const myFunc = function() { const myVar = &quot;value&quot;; return myVar;} ES6 提供了其他写匿名函数的方式的语法糖。 你可以使用箭头函数： 1234const myFunc = () =&gt; { const myVar = &quot;value&quot;; return myVar;} 当不需要函数体，只返回一个值的时候，箭头函数允许你省略 return 关键字和外面的大括号。 这样就可以将一个简单的函数简化成一个单行语句。 1const myFunc = () =&gt; &quot;value&quot;; 这段代码默认会返回字符串 value。 简洁写法1const multiplier = (item, multi) =&gt; item * multi; 1234567891011const getMousePosition = (x, y) =&gt; { return { x: x, y: y }};const getMousePosition = (x, y) =&gt; ({ x: x, y: y});const getMousePosition = (x, y) =&gt; ({ x, y }); ()=&gt;{return{}}==()=&gt;({}) 默认参数1const greeting = (name = &quot;Anonymous&quot;) =&gt; &quot;Hello &quot; + name; rest操作符rest 操作符可以用于创建有一个变量来接受多个参数的函数。 这些参数被储存在一个可以在函数内部读取的数组中。 123function howMany(...args) { return &quot;You have passed &quot; + args.length + &quot; arguments.&quot;;} sum 函数可以接收任意数量的参数，并返回它们的总和。 123const sum = (...args) =&gt; { return args.reduce((a, b) =&gt; a + b, 0);} 展开操作符将数组展开成一系列由逗号分隔的参数 123const arr = [6, 89, 3, 45];const [a, b, ...arr] = [1, 2, 3, 4, 5, 7];const maximus = Math.max(...arr); 解构赋值12345678910111213141516const user = { name: 'John Doe', age: 34 };const { name, age } = user;const { name: userName, age: userAge } = user;//解构嵌套对象中的值const user = { johnDoe: { age: 34, email: 'johnDoe@freeCodeCamp.com' }};const { johnDoe: { age: userAge, email: userEmail }} = user;//函数参数中解构对象const profileUpdate = ({ name, age, nationality, location }) =&gt; {} 解构数组12345678const [a, b] = [1, 2, 3, 4, 5, 6];console.log(a, b);//1, 2const [a, b,,, c] = [1, 2, 3, 4, 5, 6];console.log(a, b, c);//1, 2, 5const [a, b, ...arr] = [1, 2, 3, 4, 5, 7];console.log(a, b);//1, 2console.log(arr);//[3, 4, 5, 7] 模板字符串12345678910const person = { name: &quot;Zodiac Hasbro&quot;, age: 56};const greeting = `Hello, my name is ${person.name}!I am ${person.age} years old.`;console.log(greeting);// Hello, my name is Zodiac Hasbro! 和 I am 56 years old. 编写简洁的对象字面量声明123456const getMousePosition = (x, y) =&gt; ({ x: x, y: y});//getMousePosition 简单的函数，返回拥有两个属性的对象。 ES6 提供了一个语法糖，消除了类似 x: x 这种冗余的写法。 你可以只写一次 x，解释器会自动将其转换成 x: x（或效果相同的内容）。 下面是使用这种语法重写的同样的函数：const getMousePosition = (x, y) =&gt; ({ x, y }); 编写简洁的函数说明123456789101112const person = { name: &quot;Taylor&quot;, sayHello: function() { return `Hello! My name is ${this.name}.`; }};const person = { name: &quot;Taylor&quot;, sayHello() { return `Hello! My name is ${this.name}.`; }}; class语法构建函数12345678910111213const person = { name: &quot;Taylor&quot;, sayHello() { return `Hello! My name is ${this.name}.`; }};//class的应用class SpaceShuttle { constructor(targetPlanet) { this.targetPlanet = targetPlanet; }}const zeus = new SpaceShuttle('Jupiter'); 123456789101112class Book { constructor(author) { this._author = author; } // getter(变量名不能与get或set重名（author!=writer）) get writer() { return this._author; } // setter set writer(updatedAuthor) { this._author = updatedAuthor; } 模块脚本为了让 JavaScript 更模块化、更整洁以及更易于维护，ES6 引入了在多个 JavaScript 文件之间共享代码的机制。 它可以导出文件的一部分供其它文件使用，然后在需要它的地方按需导入。 为了使用这一功能， 需要在 HTML 文档里创建一个 type 为 module 的脚本。 例子如下： 1&lt;script type=&quot;module&quot; src=&quot;filename.js&quot;&gt;&lt;/script&gt; 假设有一个文件 math_functions.js，该文件包含了数学运算相关的一些函数。 其中一个存储在变量 add 里，该函数接受两个数字作为参数返回它们的和。 你想在几个不同的 JavaScript 文件中使用这个函数。 要实现这个目的，就需要 export 它。 12345678910111213141516171819export const add = (x, y) =&gt; { return x + y;}/////const add = (x, y) =&gt; { return x + y;}export { add, subtract };//默认导出的 export,在文件中只有一个值需要导出的时候，通常会使用这种语法。 它也常常用于给文件或者模块创建返回值。//命名函数export default function add(x, y) { return x + y;}//匿名函数export default function(x, y) { return x + y;}//导出方式import add from &quot;./math_functions.js&quot;; import 可以导入文件或模块的一部分。 在之前的课程里，例子从 math_functions.js 文件里导出了 add。 下面看一下如何在其它文件导入它： 123456import { add, subtract } from './math_functions.js';uppercaseString(&quot;hello&quot;);import * as myMathModule from &quot;./math_functions.js&quot;;stringFunctions.uppercaseString(&quot;hello&quot;);stringFunctions.lowercaseString(&quot;WORLD!&quot;); PromisePromise 是异步编程的一种解决方案 - 它在未来的某时会生成一个值。 任务完成，分执行成功和执行失败两种情况。 Promise 是构造器函数，需要通过 new 关键字来创建。 构造器参数是一个函数，该函数有两个参数 - resolve 和 reject。 通过它们来判断 promise 的执行结果。 用法如下： 123const myPromise = new Promise((resolve, reject) =&gt; {}); Promise 有三个状态：pending、fulfilled 和 rejected。上述例子里创建的 promise 一直阻塞在 pending 状态里，因为没有调用 promise 的完成方法。 Promise 提供的 resolve 和 reject 参数就是用来结束 promise 的。 Promise 成功时调用 resolve，promise 执行失败时调用 reject， 如下文所述，这些方法需要有一个参数。 1234567891011const myPromise = new Promise((resolve, reject) =&gt; { if(condition here) { resolve(&quot;Promise was fulfilled&quot;); } else { reject(&quot;Promise was rejected&quot;); }});//回调函数myPromise.then(result =&gt; { }); 当 promise 完成 resolve 时会触发 then 方法。 123myPromise.then(result =&gt; {}); 当 promise 失败时会调用 catch 方法。 当 promise 的 reject 方法执行时会直接调用。 用法如下： 123myPromise.catch(error =&gt; {}); 正则表达式创建正则表达式1234//1.包含在斜杠之间var re = /ab+c/;//2.调用RegExp对象的构造函数var re = new RegExp(&quot;ab+c&quot;); 简单模式/abc/能且仅能匹配 “abc” 字符按照顺序同时出现的情况。比如”Grab crab” 会匹配失败，因为中间存在空格使得abc不连续 断言表示一个匹配在某些条件下发生。断言包含先行断言、后行断言和条件表达式。 边界类断言 字符 含义 ^ 匹配输入的开头，多行模式为true时，可以匹配字符串开头（字符串的开始位置），也可以匹配行的开头（即换行符\\n之后的位置）（/^A/ 匹配不了 “an A” 里面的 “A”，但是可以匹配 “An A” 里面第一个 “A”。） $ 匹配输入的结束，多行模式为true时，可以匹配字符串结尾（字符串的结束位置）, 也可以匹配行的结尾（即换行符\\n之前的位置）（比如 /t$/ 不能匹配 “eater” 中的 “t”，但是可以匹配 “eat” 中的 “t”。） \\b 匹配一个单词的边界，这是一个字的字符前后没有另一个字的字符位置，例如在字母和空格之间。(/\\bm/在 “moon” 中匹配到 “m”)(/oo\\b/在 “moon” 中不会匹配到 “oo”, 因为 “oo” 后面跟着 “n” 这个单词字符)(/oon\\b/在 “moon” 中匹配 “oon”， 因为 “oon” 是这个字符串的结尾，因此后面没有单词字符)（/\\w\\b\\w/将永远不会匹配任何东西，因为一个单词字符后面永远不会有非单词字符和单词字符。） \\B 匹配非单词边界。这是上一个字符和下一个字符属于同一类型的位置：要么两者都必须是单词，要么两者都必须是非单词，例如在两个字母之间或两个空格之间。字符串的开头和结尾被视为非单词。与匹配的词边界相同，匹配的非词边界也不包含在匹配中。例如，/\\Bon/ 在 “at noon” 中匹配 “on” ，/ye\\B/ 在 “possibly yesterday”中匹配”ye” 。 12345678910111213141516171819//例1 （匹配输入的开头）let fruits = [&quot;Apple&quot;, &quot;Watermelon&quot;, &quot;Orange&quot;, &quot;Avocado&quot;, &quot;Strawberry&quot;];// 使用正则 /^A/ 选择以'A'开头的水果。// 这里的 '^' 只有一种含义：匹配输入的开头。let fruitsStartsWithA = fruits.filter(fruit =&gt; /^A/.test(fruit));console.log(fruitsStartsWithA); // [ 'Apple', 'Avocado' ]//例2 匹配不是 ‘A’开头的let fruits = [&quot;Apple&quot;, &quot;Watermelon&quot;, &quot;Orange&quot;, &quot;Avocado&quot;, &quot;Strawberry&quot;];// 使用正则 /^[^A]/ 选择 不是以 ‘A’ 开头的水果// 在这个例子中，“^” 控件符号表示两种含义：// 1) 匹配输入的开头// 2) 一个否定的字符集: [^A] ，意思是匹配不是 ‘A’ 的字符let fruitsStartsWithNotA = fruits.filter(fruit =&gt; /^[^A]/.test(fruit));console.log(fruitsStartsWithNotA); // [ 'Watermelon', 'Orange', 'Strawberry' ] 其他断言 字符 含义 x(?=y) 向前断言： x 被 y 跟随时匹配 x。例如，对于/Jack(?=Sprat)/，“Jack”在跟有“Sprat”的情况下才会得到匹配．`/Jack(?=Sprat x(?!y) 向前否定断言： x 没有被 y 紧随时匹配 x。例如，对于/\\d+(?!\\.)/，数字后没有跟随小数点的情况下才会得到匹配。对于/\\d+(?!\\.)/.exec(3.141)，匹配‘141’而不是‘3’。 (?&lt;=y)x 向后断言： x 跟随 y 的情况下匹配 x。例如，对于/(?&lt;=Jack)Sprat/，“Sprat”紧随“Jack”时才会得到匹配。对于`/(?&lt;=Jack (?&lt;!y)x 向后否定断言： x 不跟随 y 时匹配 x。例如，对于/(?&lt;!-)\\d+/，数字不紧随 - 符号的情况下才会得到匹配。对于/(?&lt;!-)\\d+/.exec(3) ，“3”得到匹配。 而/(?&lt;!-)\\d+/.exec(-3)的结果无匹配，这是由于数字之前有 - 符号。 字符类 字符 含义 . 匹配除行终止符之外的任何单个字符(/.y/ 在“yes make my day”中匹配“my”和“ay”，而不是“yes”，而/y./匹配的是“ye”与“y”) \\d 匹配任何数字 (阿拉伯数字)。相当于 [0-9]。例如，/\\d/ 或 /[0-9]/ 匹配“B2is the suite number”中的“2”。 \\D 匹配任何非数字 (阿拉伯数字) 的字符。相当于[^0-9]。例如，/\\D/ 或者 /[^0-9]/ 匹配“B2 is the suite number”中的“B”。 \\w 匹配基本拉丁字母中的任何字母数字字符，包括下划线。相当于 [A-Z，a-z，0-9，_]。例如，/\\w/ 匹配“apple”中的“a”，“p”，“p”，“l”，“e”，匹配“$5.28”中的“5”，匹配“3D”中的“3”，以及匹配“Émanuel”中的“m”。 \\W 匹配任何不是来自基本拉丁字母的单词字符。相当于 [^A-Za-z0-9_]。例如，/\\W/ 或者 /[^A-Za-z0-9_]/ 匹配“50%”中的“%”，以及匹配“Émanuel”中的“É”。 \\s 匹配单个空白字符，包括空格、制表符、换页符、换行符和其他 Unicode 空格。相当于 [ \\f\\n\\r\\t\\v\\u00a0\\u1680\\u2000-\\u200a\\u2028\\u2029\\u202f\\u205f\\u3000\\ufeff]。例如，/\\s\\w*/ 匹配“foo bar”中的“ bar”。 \\S 匹配除空格以外的单个字符。相当于 [^ \\f\\n\\r\\t\\v\\u00a0\\u1680\\u2000-\\u200a\\u2028\\u2029\\u202f\\u205f\\u3000\\ufeff]。例如，/\\S\\w*/ 匹配“foo bar”中的“foo”。 \\t 匹配水平制表符。 \\r 匹配回车符。 \\n 匹配换行符。 \\v 匹配垂直制表符。 \\f 匹配换页符。 [\\b] 匹配退格键。如果您正在寻找单词边界字符（\\b） \\0 匹配一个 NUL 字符。不要在此后面加上另一个数字。 \\cX 使用插入符号匹配控制字符，其中“X”是 A–Z 中的一个字母（对应于代码点 U+0001–U+001F）。例如，/\\cM\\cJ/匹配“\\r\\n”。 \\xhh 匹配与代码 *hh*（两个十六进制数字）对应的字符。 \\uhhhh 匹配与值 *hhhh*（四个十六进制数字）对应的 UTF-16 代码单元。 \\u{hhhh} 或 \\u{hhhhh} （仅当设置了 u 标志时。）匹配与 Unicode 值 U+*hhhh* 或 U+*hhhhh*（十六进制数字）对应的字符。 使用特殊字符当你需要匹配一个不确定的字符串时，比如寻找一个或多个 “b”，或者寻找空格，可以在模式中使用特殊字符。比如，你可以使用 /ab*c/ 去匹配一个单独的 “a” 后面跟了零个或者多个 “b”，同时后面跟着 “c” 的字符串：*的意思是前一项出现零次或者多次。在字符串 “abbbbc” 中，这个模式匹配了子字符串 “abbbbc”。 [-6,-1,5,4,1,-8,6,7,-3,6,0,-6,-7,8,-8,-4,1] 应用如果想要在字符串 The dog chased the cat 中匹配到 the 这个单词，可以使用如下正则表达式：/the/。 注意，正则表达式中不需要引号。 JavaScript 中有多种使用正则表达式的方法。 测试正则表达式的一种方法是使用 .test() 方法。 .test() 方法会把编写的正则表达式和字符串（即括号内的内容）完全匹配（区分大小写），如果成功匹配到字符，则返回 true，反之，返回 false。 123let testStr = &quot;freeCodeCamp&quot;;let testRegex = /Code/;testRegex.test(testStr); 搜索多个模式|这对于搜寻单个字符串非常有用，但仅限于一种匹配模式。 你可以使用 alternation 或 OR 操作符搜索多个模式： | 此操作符匹配操作符前面或后面的字符。 例如，如果你想匹配 yes 或 no，你需要的正则表达式是 /yes|no/。 你还可以匹配多个规则，这可以通过添加更多的匹配模式来实现。 这些匹配模式将包含更多的 OR 操作符来分隔它们，比如/yes|no|maybe/。 1let petRegex = /dog|cat|bird|fish/ 匹配忽略大小写可以使用标志（flag）来匹配这两种情况。 标志有很多，不过这里我们只关注忽略大小写的标志——i。 可以通过将它附加到正则表达式之后来使用它。 这里给出使用该标志的一个实例 /ignorecase/i。 这个字符串可以匹配字符串 ignorecase、igNoreCase 和 IgnoreCase。 123let myString = &quot;freeCodeCamp&quot;;let fccRegex = /freecodecamp/i; // 修改这一行let result = fccRegex.test(myString); 提取找到的实际匹配项match提取或搜寻一次模式匹配 12345&quot;Hello, World!&quot;.match(/Hello/);let ourStr = &quot;Regular expressions&quot;;let ourRegex = /expressions/;ourStr.match(ourRegex);//这里第一个 match 将返回 [&quot;Hello&quot;] 第二个将返回 [&quot;expressions&quot;]。 多次搜寻或提取模式匹配g 12let repeatRegex = /Repeat/g;testStr.match(repeatRegex); 在正则表达式上可以有多个标志，比如 /search/gi 用通配符匹配任何内容.通配符 . 将匹配任何一个字符。 通配符也叫 dot 或 period。 可以像使用正则表达式中任何其他字符一样使用通配符。 例如，如果想匹配 hug、huh、hut 和 hum，可以使用正则表达式 /hu./ 匹配以上四个单词。 12345let humStr = &quot;I'll hum a song&quot;;let hugStr = &quot;Bear hug&quot;;let huRegex = /hu./;huRegex.test(humStr);huRegex.test(hugStr); 将单个字符与多种可能性匹配可以使用字符集 （character classes）更灵活的匹配字符。 可以把字符集放在方括号（[ 和 ]）之间来定义一组需要匹配的字符串。 例如，如果想要匹配 bag、big 和 bug，但是不想匹配 bog。 可以创建正则表达式 /b[aiu]g/ 来执行此操作。 [aiu] 是只匹配字符 a、i 或者 u 的字符集。 在字符集中，可以使用连字符（-）来定义要匹配的字符范围。 例如，要匹配小写字母 a 到 e，你可以使用 [a-e]。 使用连字符（-）匹配字符范围并不仅限于字母。 它还可以匹配一系列数字。 例如，/[0-5]/ 匹配 0 和 5 之间的任意数字，包含 0 和 5。 此外，还可以在单个字符集中组合一系列字母和数字。 /[a-z0-9]/ig 123456789let bigStr = &quot;big&quot;;let bagStr = &quot;bag&quot;;let bugStr = &quot;bug&quot;;let bogStr = &quot;bog&quot;;let bgRegex = /b[aiu]g/;bigStr.match(bgRegex);bagStr.match(bgRegex);bugStr.match(bgRegex);bogStr.match(bgRegex); 匹配单个未指定的字符^（匹配字符串开始位置） 匹配输入字符串的开始位置，除非在方括号([])表达式中使用，当该符号在方括号表达式中使用时，表示不接受该方括号表达式中的字符集合。要匹配 ^ 字符本身，请使用 ^。 [^abcd] 创建一个不想匹配的字符集合。 这些类型的字符集称为否定字符集（ negated character sets）。 要创建否定字符集，需要在开始括号后面和不想匹配的字符前面放置脱字符（即^）。 例如，/[^aeiou]/gi 匹配所有非元音字符。 注意，字符 .、!、[、@、/ 和空白字符等也会被匹配，该否定字符集仅排除元音字符。 \\^abcd 匹配输入字符串开始位置 匹配出现一次或多次的字符+有时，需要匹配出现一次或者连续多次的的字符（或字符组）。 这意味着它至少出现一次，并且可能重复出现。 可以使用 + 符号来检查情况是否如此。 记住，字符或匹配模式必须一个接一个地连续出现。 这就是说，字符必须一个接一个地重复。 例如，/a+/g 会在 abc 中匹配到一个匹配项，并且返回 [&quot;a&quot;]。 因为 + 的存在，它也会在 aabc 中匹配到一个匹配项，然后返回 [&quot;aa&quot;]。 如果它是检查字符串 abab，它将匹配到两个匹配项并且返回[&quot;a&quot;, &quot;a&quot;]，因为a字符不连续，在它们之间有一个b字符。 最后，因为在字符串 bcd 中没有 a，因此找不到匹配项。 匹配出现零次或多次的字符*1234567let soccerWord = &quot;gooooooooal!&quot;;let gPhrase = &quot;gut feeling&quot;;let oPhrase = &quot;over the moon&quot;;let goRegex = /go*/;soccerWord.match(goRegex);//[&quot;goooooooo&quot;]gPhrase.match(goRegex);//[&quot;g&quot;]oPhrase.match(goRegex);//null 用惰性匹配来查找字符?在正则表达式中，贪婪（greedy）匹配会匹配到符合正则表达式匹配模式的字符串的最长可能部分，并将其作为匹配项返回。 另一种方案称为懒惰（lazy）匹配，它会匹配到满足正则表达式的字符串的最小可能部分。 可以将正则表达式 /t[a-z]*i/ 应用于字符串 &quot;titanic&quot;。 这个正则表达式是一个以 t 开始，以 i 结束，并且中间有一些字母的匹配模式。 正则表达式默认是贪婪匹配，因此匹配返回为 [&quot;titani&quot;]。 它会匹配到适合该匹配模式的最大子字符串。 但是，你可以使用 ? 字符来将其变成懒惰匹配。 调整后的正则表达式 /t[a-z]*?i/ 匹配字符串 &quot;titanic&quot; 返回 [&quot;ti&quot;]。 检查全部或无?有时，想要搜寻的匹配模式可能有不确定是否存在的部分。 尽管如此，还是想检查它们。 为此，可以使用问号 ? 指定可能存在的元素。 这将检查前面的零个或一个元素。 可以将此符号视为前面的元素是可选的。 例如，美式英语和英式英语略有不同，可以使用问号来匹配两种拼写。 12345let american = &quot;color&quot;;let british = &quot;colour&quot;;let rainbowRegex= /colou?r/;rainbowRegex.test(american);//truerainbowRegex.test(british);//true 匹配字符串结尾$12345let theEnding = &quot;This is a never ending story&quot;;let storyRegex = /story$/;storyRegex.test(theEnding);let noEnding = &quot;Sometimes a story will have to end&quot;;storyRegex.test(noEnding); 匹配所有的字母和数字\\wJavaScript 中与字母表匹配的最接近的元字符是\\w。 这个缩写等同于[A-Za-z0-9_]。 此字符类匹配大写字母和小写字母以及数字。 注意，这个字符类也包含下划线字符 (_)。 有可能想要搜寻的匹配模式是非字母数字字符。 可以使用 \\W 搜寻和 \\w 相反的匹配模式。 注意，相反匹配模式使用大写字母。 此缩写与 [^A-Za-z0-9_] 是一样的。 匹配所有数字\\d,\\D查找数字字符的缩写是 \\d，注意是小写的 d。 这等同于元字符 [0-9]，它查找 0 到 9 之间任意数字的单个字符。 查找非数字字符的缩写是 \\D。 这等同于字符串 [^0-9]，它查找不是 0 - 9 之间数字的单个字符。 匹配空白字符\\s可以使用 \\s 搜寻空格，其中 s 是小写。 此匹配模式将匹配空格、回车符、制表符、换页符和换行符。 可以认为这类似于元字符 [ \\r\\t\\f\\n\\v]。 使用 \\S 搜寻非空白字符，其中 s 是大写。 此匹配模式将不匹配空格、回车符、制表符、换页符和换行符。 可以认为这类似于元字符 [^ \\r\\t\\f\\n\\v]。 指定匹配的上限和下限可以使用数量说明符（quantity specifiers）指定匹配模式的上下限。 数量说明符与花括号（{ 和 }）一起使用。 可以在花括号之间放两个数字，这两个数字代表匹配模式的上限和下限。 例如，要匹配出现 3 到 5 次字母 a 的在字符串 ah，正则表达式应为/a{3,5}h/。 12345678910let A4 = &quot;aaaah&quot;;let A2 = &quot;aah&quot;;let multipleA = /a{3,5}h/;multipleA.test(A4);multipleA.test(A2);//============//修改正则表达式 ohRegex 以匹配出现 3 到 6 次字母 h 的字符串 Oh no。let ohStr = &quot;Ohhh no&quot;;let ohRegex = /Oh{3,6}\\sno/g; // 修改这一行let result = ohRegex.test(ohStr); 只指定匹配的下限 在第一个数字后面跟一个逗号即可。 例如，要匹配至少出现 3 次字母 a 的字符串 hah，正则表达式应该是 /ha{3,}h/ 1234567let A4 = &quot;haaaah&quot;;let A2 = &quot;haah&quot;;let A100 = &quot;h&quot; + &quot;a&quot;.repeat(100) + &quot;h&quot;;let multipleA = /ha{3,}h/;multipleA.test(A4);multipleA.test(A2);multipleA.test(A100); 指定匹配的确切数量 要指定一定数量的匹配模式，只需在大括号之间放置一个数字。 例如，要只匹配字母 a 出现 3 次的单词hah，正则表达式应为/ha{3}h/。 正向先行断言和负向先行断言先行断言 （Lookaheads）是告诉 JavaScript 在字符串中向前查找的匹配模式。 当想要在同一个字符串上搜寻多个匹配模式时，这可能非常有用。 有两种先行断言：正向先行断言（positive lookahead）和负向先行断言（negative lookahead）。 正向先行断言会查看并确保搜索匹配模式中的元素存在，但实际上并不匹配。 正向先行断言的用法是 (?=...)，其中 ... 就是需要存在但不会被匹配的部分。 另一方面，负向先行断言会查看并确保搜索匹配模式中的元素不存在。 负向先行断言的用法是 (?!...)，其中 ... 是希望不存在的匹配模式。 如果负向先行断言部分不存在，将返回匹配模式的其余部分。 123456let quit = &quot;qu&quot;;let noquit = &quot;qt&quot;;let quRegex= /q(?=u)/;let qRegex = /q(?!u)/;quit.match(quRegex);//[&quot;q&quot;]noquit.match(qRegex);//[&quot;q&quot;] 先行断言的更实际用途是检查一个字符串中的两个或更多匹配模式。 这里有一个简单的密码检查器，密码规则是 3 到 6 个字符且至少包含一个数字： 123let password = &quot;abc123&quot;;let checkPass = /(?=\\w{3,6})(?=\\D*\\d)/;checkPass.test(password); 检查混合字符组有时候我们想使用正则表达式里的括号 () 来检查字符组。 如果想在字符串找到 Penguin 或 Pumpkin，可以用这个正则表达式：/P(engu|umpk)in/g。 然后使用 test() 方法检查 test 字符串里面是否包含字符组。 123let testStr = &quot;Pumpkin&quot;;let testRegex = /P(engu|umpk)in/;testRegex.test(testStr); 捕获组当你想要匹配一个像下面这样多次出现的单词， 1let repeatStr = &quot;row row row your boat&quot;; 你可以使用 /row row row/。但如果你不知道重复的特定单词，怎么办？ 捕获组 可以用于找到重复的子字符串。 捕获组是通过把要捕获的正则表达式放在括号中来构建的。 在这个例子里， 目标是捕获一个包含字母数字字符的词，所以捕获组是将 \\w+ 放在括号中：/(\\w+)/。 分组匹配的子字符串被保存到一个临时的“变量”， 可以使用同一正则表达式和反斜线及捕获组的编号来访问它（例如：\\1）。 捕获组按其开头括号的位置自动编号（从左到右），从 1 开始。 下面的示例是匹配被空格隔开的两个相同单词： 123let repeatRegex = /(\\w+) \\1 \\1/;repeatRegex.test(repeatStr); // Returns truerepeatStr.match(repeatRegex); // Returns [&quot;row row row&quot;, &quot;row&quot;] 在字符串上调用 .match() 方法将返回一个数组，其中包含它\b最终匹配到的子字符串及其捕获组。 在 reRegex 中使用捕获组来匹配一个只由相同的数字重复三次组成的由空格分隔字符串。 123let repeatNum = &quot;42 42 42&quot;;let reRegex = /^(\\d+)\\s\\1\\s\\1$/; // 修改这一行let result = reRegex.test(repeatNum); 搜索或替换搜索功能是很有用的。 但是，当搜索同时也执行更改（或替换）匹配文本的操作时，搜索功能就会显得更加强大。 可以在字符串上使用 .replace() 方法来搜索并替换字符串中的文本。 .replace() 的输入首先是想要搜索的正则表达式匹配模式。 第二个参数是用于替换匹配的字符串或用于执行某些操作的函数。 123let wrongText = &quot;The sky is silver.&quot;;let silverRegex = /silver/;wrongText.replace(silverRegex, &quot;blue&quot;); replace 调用将返回字符串 The sky is blue.。 你还可以使用美元符号（$）访问替换字符串中的捕获组。 1&quot;Code Camp&quot;.replace(/(\\w+)\\s(\\w+)/, '$2 $1'); 调用 replace 将返回字符串 Camp Code。 删除开头和结尾的空白有时字符串周围存在的空白字符并不是必需的。 字符串的典型处理是删除字符串开头和结尾处的空格。 编写一个正则表达式并使用适当的字符串方法删除字符串开头和结尾的空格。 注意： String.prototype.trim() 方法在这里也可以实现同样的效果，但是你需要使用正则表达式来完成此项挑战。 123let hello = &quot; Hello, World! &quot;;let wsRegex = /^\\s+|\\s+$/g; // 修改这一行let result = hello.replace(wsRegex,&quot;&quot;); // 修改这一行 函数式编程函数式编程是一种方案简单、功能独立、对作用域外没有任何副作用的编程范式：INPUT -&gt; PROCESS -&gt; OUTPUT。 函数式编程： 1）功能独立——不依赖于程序的状态（比如可能发生变化的全局变量）； 2）纯函数——同一个输入永远能得到同一个输出； 3）有限的副作用——可以严格地限制函数外部对状态的更改。 Callbacks 是被传递到另一个函数中调用的函数。 你应该已经在其他函数中看过这个写法，例如在 filter 中，回调函数告诉 JavaScript 以什么规则过滤数组。 函数就像其他正常值一样，可以赋值给变量、传递给另一个函数，或从其它函数返回，这种函数叫做头等 first class 函数。 在 JavaScript 中，所有函数都是头等函数。 将函数为参数或返回值的函数叫做高阶 ( higher order) 函数。 当函数被传递给另一个函数或从另一个函数返回时，那些传入或返回的函数可以叫做 lambda。 函数式编程的核心原则之一是不改变任何东西。 变化会导致错误。 如果一个函数不改变传入的参数、全局变量等数据，那么它造成问题的可能性就会小很多。 前面的例子没有任何复杂的操作，但是 splice 方法改变了原始数组，导致 bug 产生。 回想一下，在函数式编程中，改变或变更叫做 mutation，这种改变的结果叫做“副作用”（side effect）。 理想情况下，函数应该是不会产生任何副作用的 pure function。 让我们尝试掌握这个原则：不要改变代码中的任何变量或对象。 123456// 全局变量let fixedValue = 4;function incrementer() { return fixedValue+1} 虽然我们没有改变全局变量值，但在没有全局变量 fixedValue 的情况下，incrementer 函数将不起作用。 函数式编程的另一个原则是：总是显式声明依赖关系。 如果函数依赖于一个变量或对象，那么将该变量或对象作为参数直接传递到函数中。 这样做会有很多好处。 其中一点是让函数更容易测试，因为你确切地知道参数是什么，并且这个参数也不依赖于程序中的任何其他内容。 其次，这样做可以让你更加自信地更改，删除或添加新代码。 因为你很清楚哪些是可以改的，哪些是不可以改的，这样你就知道哪里可能会有潜在的陷阱。 最后，无论代码的哪一部分执行它，函数总是会为同一组输入生成相同的输出。 1234567// 全局变量let fixedValue = 4;// 只修改这一行下面的代码function incrementer(param) { return param+1} 目前为止，我们已经看到了函数式编程的两个原则： 不要更改变量或对象 - 创建新变量和对象，并在需要时从函数返回它们。 提示：使用类似 const newArr = arrVar 的东西，其中 arrVar 是一个数组，只会创建对现有变量的引用，而不是副本。 所以更改 newArr 中的值会同时更改 arrVar 中的值。 声明函数参数 - 函数内的任何计算仅取决于参数，而不取决于任何全局对象或变量。 reduce方法分析数据reduce()（即Array.prototype.reduce()），是 JavaScript 所有数组操作中最常用的方法。 几乎可以用reduce方法解决所有数组处理问题。 reduce方法是处理数组更通用的方式，而且filter和map方法都可以当作是reduce的特殊实现。 reduce方法遍历数组中的每个项目并返回单个值（即字符串、数字、对象、数组）。 这是通过在每次迭代中调用一个回调函数来实现的。 回调函数接受四个参数。 第一个参数称为叠加器，它是上一次迭代中回调函数的返回值，第二个参数是当前正在处理的数组元素，第三个参数是该参数的索引，第四个参数是在其上调用 reduce 方法的数组。 除了回调函数，reduce 还有一个额外的参数做为叠加器的初始值。 如果没有第二个参数，会跳过第一次迭代，第二次迭代给叠加器传入数组的第一个元素。 见下面的例子，给 users 数组使用 reduce 方法，返回所有用户数组的和。 为了简化，例子仅使用了回调函数的第一个参数和第二个参数。 12345678const users = [ { name: 'John', age: 34 }, { name: 'Amy', age: 20 }, { name: 'camperCat', age: 10 }];const sumOfAges = users.reduce((sum, user) =&gt; sum + user.age, 0);console.log(sumOfAges); 1234567891011const users = [ { name: 'John', age: 34 }, { name: 'Amy', age: 20 }, { name: 'camperCat', age: 10 }];const usersObj = users.reduce((obj, user) =&gt; { obj[user.name] = user.age; return obj;}, {});console.log(usersObj); 12345678910111213141516171819202122232425262728293031/*watchList 是包含一些电影信息的对象。 使用 reduce 查找由 Christopher Nolan 导演的电影的 IMDB 评级平均值。 回想一下之前的挑战，如何 filter 数据，以及使用 map 来获取你想要的数据。 您可能需要创建其他变量，并从 getRating 函数返回平均评分。 请注意，评级在对象中是字符串，需要将其转换为数字再用于数学运算。*/function getRating(watchList){ // Add your code below this line const averageRating = watchList // Use filter to find films directed by Christopher Nolan .filter(film =&gt; film.Director === &quot;Christopher Nolan&quot;) // Use map to convert their ratings from strings to numbers .map(film =&gt; Number(film.imdbRating)) // Use reduce to add together their ratings .reduce((sumOfRatings, rating) =&gt; sumOfRatings + rating) / // Divide by the number of Nolan films to get the average rating watchList.filter(film =&gt; film.Director === &quot;Christopher Nolan&quot;).length; // Add your code above this line return averageRating;}function getRating(watchList) { // Add your code below this line const nolanData = watchList .reduce((data, { Director: director, imdbRating: rating }) =&gt; { if (director === 'Christopher Nolan') { data.count++; data.sum += Number(rating); } return data; }, { sum: 0, count: 0 }); const averageRating = nolanData.sum / nolanData.count; // Add your code above this line return averageRating;} sort排序sort 方法可以根据回调函数对数组元素进行排序。 举个例子： 1234567function ascendingOrder(arr) { return arr.sort(function(a, b) { return a - b; });}ascendingOrder([1, 5, 2, 3, 4]); 这将返回值 [1, 2, 3, 4, 5]。 1234567function reverseAlpha(arr) { return arr.sort(function(a, b) { return a === b ? 0 : a &lt; b ? 1 : -1; });}reverseAlpha(['l', 'h', 'z', 'b', 's']); 这将返回值 ['z', 's', 'l', 'h', 'b']。 JavaScript 的默认排序方法是 Unicode 值顺序排序，有时可能会得到意想不到的结果。 因此，建议提供一个回调函数来指定如何对数组项目排序。 这个回调函数通常叫做 compareFunction，它根据 compareFunction 的返回值决定数组元素的排序方式： 如果两个元素 a 和 b，compareFunction(a,b) 返回一个比 0 小的值，那么 a 会在 b 的前面。 如果两个元素 a 和 b，compareFunction(a,b) 返回一个比 0 大的值，那么 b 会在 a 的前面。 如果两个元素 a 和 b，compareFunction(a,b) 返回等于 0 的值，那么 a 和 b 的位置保持不变。 123456789function alphabeticalOrder(arr) { // 只修改这一行下面的代码 return arr.sort(function(a,b){ return a.charCodeAt()-b.charCodeAt() }) // 只修改这一行上面的代码}alphabeticalOrder([&quot;a&quot;, &quot;d&quot;, &quot;c&quot;, &quot;a&quot;, &quot;z&quot;, &quot;g&quot;]); sort 方法会产生改变原始数组中元素顺序的副作用。 换句话说，它会改变数组的位置。 避免这种情况的一种方法是先将空数组连接到正在排序的数组上（记住 slice 和 concat 返回一个新数组），再用sort方法。 split方法（切割字符串成数组）split 方法将一个字符串分割成一个字符串数组。 它需要一个参数作为分隔符，它可以是用于拆分字符串或正则表达式的一个字符。 举个例子，如果分隔符是空格，你会得到一个单词数组；如果分隔符是空字符串，你会得到一个由字符串中每个字符组成的数组。 下面是两个用空格分隔一个字符串的例子，另一个是用数字的正则表达式分隔： 12345const str = &quot;Hello World&quot;;const bySpace = str.split(&quot; &quot;);const otherString = &quot;How9are7you2today&quot;;const byDigits = otherString.split(/\\d/); bySpace 将有值 [&quot;Hello&quot;, &quot;World&quot;]，byDigits 将有值 [&quot;How&quot;, &quot;are&quot;, &quot;you&quot;, &quot;today&quot;]。 因为字符串是不可变的，split 方法操作它们更方便。 join方法（拼接数组字符）12const arr = [&quot;Hello&quot;, &quot;World&quot;];const str = arr.join(&quot; &quot;); every方法检查数组中每个元素是否符合条件every 方法用于检测数组中所有元素是否都符合指定条件。 如果所有元素满足条件，返回布尔值 true，反之返回 false。 举个例子，下面的代码检测数组 numbers 的所有元素是否都小于 10： 12345const numbers = [1, 5, 8, 0, 10, 11];numbers.every(function(currentValue) { return currentValue &lt; 10;}); every 方法在这里会返回 false。 some 方法检查数组中是否有元素是否符合条件some 方法用于检测数组中任何元素是否满足指定条件。 如果有一个元素满足条件，返回布尔值 true，反之返回 false。 举个例子，下面的代码检测数组numbers中是否有元素小于 10： 12345const numbers = [10, 50, 8, 220, 110, 11];numbers.some(function(currentValue) { return currentValue &lt; 10;}); some 方法将返回 true。 函数柯里化和局部调用arity（参数个数）是函数所需的形参的数量。 函数柯里化（Currying）意思是把接受多个 arity 的函数变换成接受单一 arity 的函数。 换句话说，就是重构函数让它接收一个参数，然后返回接收下一个参数的函数，依此类推。 举个例子： 12345678910111213function unCurried(x, y) { return x + y;}function curried(x) { return function(y) { return x + y; }}const curried = x =&gt; y =&gt; x + ycurried(1)(2) curried(1)(2) 会返回 3。 柯里化在不能一次为函数提供所有参数情况下很有用。 因为它可以将每个函数的调用保存到一个变量中，该变量将保存返回的函数引用，该引用在下一个参数可用时接受该参数。 下面是使用柯里化函数的例子： 12const funcForY = curried(1);console.log(funcForY(2)); // 3 类似地，局部调用（ partial application）的意思是一次对一个函数应用几个参数，然后返回另一个应用更多参数的函数。 这是一个示例： 123456function impartial(x, y, z) { return x + y + z;}const partialFn = impartial.bind(this, 1, 2);partialFn(10); // 13","link":"/2022/10/03/js%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB/"}],"tags":[{"name":"Css","slug":"Css","link":"/tags/Css/"},{"name":"Vue2","slug":"Vue2","link":"/tags/Vue2/"},{"name":"Sass","slug":"Sass","link":"/tags/Sass/"},{"name":"Html","slug":"Html","link":"/tags/Html/"},{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"}],"categories":[{"name":"学习汇总","slug":"学习汇总","link":"/categories/%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB/"}],"pages":[]}