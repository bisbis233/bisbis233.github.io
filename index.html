<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>一条懒狗的博客</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="一条懒狗的博客"><meta name="msapplication-TileImage" content="/imgs/avatar.jpg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="一条懒狗的博客"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="记录学习"><meta property="og:type" content="blog"><meta property="og:title" content="一条懒狗的博客"><meta property="og:url" content="https://bisbis233/github.io"><meta property="og:site_name" content="一条懒狗的博客"><meta property="og:description" content="记录学习"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://bisbis233/img/og_image.png"><meta property="article:author" content="一条懒狗"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://bisbis233/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://bisbis233/github.io"},"headline":"一条懒狗的博客","image":["https://bisbis233/img/og_image.png"],"author":{"@type":"Person","name":"一条懒狗"},"publisher":{"@type":"Organization","name":"一条懒狗的博客","logo":{"@type":"ImageObject","url":"https://bisbis233/imgs/avatar.jpg"}},"description":"记录学习"}</script><link rel="icon" href="/imgs/avatar.jpg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/imgs/avatar.jpg" alt="一条懒狗的博客" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item is-active" href="/">主页</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a></div><div class="navbar-end"><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2023-03-21T08:36:30.000Z" title="2023/3/21 下午4:36:30">2023-03-21</time>发表</span><span class="level-item"><time dateTime="2023-03-22T02:06:42.656Z" title="2023/3/22 上午10:06:42">2023-03-22</time>更新</span><span class="level-item">37 分钟读完 (大约5540个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/03/21/2023-3-21%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/">2023-3-21学习记录</a></h1><div class="content"><h4 id="9-2-4399前端一面-牛客网-nowcoder-com"><a href="#9-2-4399前端一面-牛客网-nowcoder-com" class="headerlink" title="9.2 4399前端一面_牛客网 (nowcoder.com)"></a><a target="_blank" rel="noopener" href="https://www.nowcoder.com/discuss/395215085923328000?sourceSSR=search">9.2 4399前端一面_牛客网 (nowcoder.com)</a></h4><ol>
<li><p>什么时候开始学习前端</p>
</li>
<li><h4 id="原型和原型链"><a href="#原型和原型链" class="headerlink" title="原型和原型链"></a>原型和原型链</h4><ol>
<li>JavaScript中的原型是一个对象，在对象创建时自动添加的一个属性名为<code>prototype</code>的隐藏属性，它包含了对该对象的构造函数的引用和对该对象实例的公共属性和方法的引用。</li>
<li>每个对象都有一个<code>prototype</code>，它指向一个该对象的构造函数对象，当在当前对象没有找到某个属性或者方法时，js就会沿着原型链向上找，直到找到或者到达原型顶端为止</li>
<li><code>_proto_</code>指向构造函数的<code>prototype</code>，<code>prototype</code>内含有当前对象构造函数的公共属性以及方法</li>
</ol>
</li>
<li><h4 id="实习过程中遇到的有挑战的项目"><a href="#实习过程中遇到的有挑战的项目" class="headerlink" title="实习过程中遇到的有挑战的项目"></a>实习过程中遇到的有挑战的项目</h4></li>
<li><h4 id="向一个div中插入1000个span"><a href="#向一个div中插入1000个span" class="headerlink" title="向一个div中插入1000个span"></a>向一个div中插入1000个span</h4><ol>
<li>使用appendchild</li>
<li>使用innerHtml</li>
</ol>
</li>
<li><h4 id="为什么要减少回流"><a href="#为什么要减少回流" class="headerlink" title="为什么要减少回流"></a>为什么要减少回流</h4><ol>
<li>回流是当页面中的元素尺寸、位置等发生了变化时，浏览器需要重新计算页面布局并重新渲染受影响。</li>
<li>回流会触发浏览器多次计算和渲染，如果页面存在多次回流将有可能造成页面卡顿，加载缓慢等问题</li>
<li>减少回流的方法：<ol>
<li>使用transform与opacity代替position或width&#x2F;height</li>
<li>避免使用table布局，因为table的渲染过程需要多次回流；</li>
<li>避免使用复杂的CSS选择器，因为这会增加浏览器的计算量，导致回流次数增加。</li>
<li>合并多个样式的修改，避免多次修改同一个元素的样式；</li>
<li>避免频繁操作DOM元素，尽可能一次性完成多个操作，或者使用（DocumentFragment，innerHtml，cloneNode）一次性插入多个元素；</li>
<li>在修改元素样式前，先将元素脱离文档流，修改完后再重新插入文档流，避免多次回流；</li>
<li>使用事件委托，将事件处理程序绑定到父元素上，而不是绑定到每个子元素上。</li>
</ol>
</li>
<li>重绘是指当元素的样式（如颜色、字体、背景等）发生变化时，浏览器会重新绘制该元素的内容，使其显示出新的样式。</li>
<li>在重绘过程中，浏览器会重新计算元素的样式，并根据计算的结果来更新元素的显示。</li>
<li>减少重绘的方法：<ol>
<li>使用CSS3的transform和opacity属性来实现动画效果，这些属性可以让浏览器使用GPU来进行渲染，避免重绘。</li>
<li>避免频繁地修改元素的样式，可以将多次修改样式的操作合并为一次，减少重绘的次数。</li>
<li>使用CSS的will-change属性来告诉浏览器哪些元素将要进行变换，从而提前进行优化，避免重绘。</li>
</ol>
</li>
</ol>
</li>
<li><h4 id="v-for中的key有什么作用，如果没有key会怎样"><a href="#v-for中的key有什么作用，如果没有key会怎样" class="headerlink" title="v-for中的key有什么作用，如果没有key会怎样"></a>v-for中的key有什么作用，如果没有key会怎样</h4><ol>
<li>在Vue中，<code>key</code>是用来识别<code>v-for</code>中的每个元素的唯一标识符。当数据发生变化时，Vue会根据<code>key</code>的变化来判断哪些元素是新增的、哪些元素是更新的、哪些元素是删除的，从而避免不必要的DOM操作，提高性能。</li>
<li>如果不给<code>v-for</code>中的元素设置<code>key</code>，Vue会默认使用每个元素的索引作为<code>key</code>。这样做虽然可以正常渲染，但是当数据变化时，Vue只能通过比较索引来判断元素是否变化，这可能会导致一些问题，例如：<ol>
<li>当新元素被添加到列表的开头或中间时，原本在该位置的元素会被移动到新的位置，而不是创建一个新元素。</li>
<li>当元素被删除时，后面的元素的<code>key</code>会发生变化，从而可能导致不必要的DOM操作。</li>
</ol>
</li>
</ol>
</li>
<li><h4 id="浏览器渲染页面流程"><a href="#浏览器渲染页面流程" class="headerlink" title="浏览器渲染页面流程"></a>浏览器渲染页面流程</h4><ol>
<li>解析HTML：浏览器通过网络请求获取HTML文件，并对文件进行解析，构建DOM树。</li>
<li>解析CSS：浏览器将解析到的CSS样式文件与DOM树结合，构建出渲染树（Render Tree）。</li>
<li>布局计算：渲染树中每个节点的尺寸、位置等属性进行计算，生成布局（Layout）。</li>
<li>绘制：将布局转化为绘制指令，并生成绘制图形，即将HTML、CSS和JavaScript代码转换成可视化的界面。</li>
<li>合成：浏览器将不同图层的绘制结果按照规定的顺序合成为最终的页面图像。</li>
<li>显示：将页面图像显示在浏览器窗口中。</li>
<li>重绘和回流：当页面中的元素发生变化时，浏览器会重新计算布局和绘制，因此可能会发生重绘和回流的过程，影响页面性能。</li>
</ol>
</li>
<li><h4 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h4><p>是实现 JavaScript 异步编程的重要手段。基本流程是</p>
<ol>
<li>执行同步任务，也就是按照代码顺序执行。</li>
<li>当遇到异步任务时，将其添加到任务队列（task queue）中，等待执行。</li>
<li>当同步任务执行完毕后，事件循环会不断地从任务队列中取出一个任务，执行它。</li>
<li>当任务执行完毕后，如果任务队列中还有任务，事件循环会继续取出任务执行，直到任务队列为空。</li>
<li>如果任务队列为空，事件循环会等待新的任务加入队列，然后继续执行任务。</li>
</ol>
<p>事件循环的执行顺序为：</p>
<ol>
<li>执行完当前宏任务后，检查微任务队列，如果有微任务，则依次取出所有微任务执行。</li>
<li>当微任务队列为空时，检查宏任务队列，如果有宏任务，则取出一个宏任务执行。</li>
<li>重复上述步骤，直到两个任务队列都为空。</li>
</ol>
</li>
<li><h4 id="vue的响应式原理"><a href="#vue的响应式原理" class="headerlink" title="vue的响应式原理"></a>vue的响应式原理</h4><ol>
<li><p>vue2的原理：</p>
<ol>
<li><p>vue2通过<code>Object.defineProperty()</code>实现，在vue创建时会把data进行递归遍历，使用<code>Object.defineProperty()</code>将每一个属性转换为<code>getter</code>与<code>setter</code>,并在数据发生变化时通过setter通知所有组件更新视图</p>
</li>
<li><p>vue3使用<code>Proxy</code>代替<code>Object.defineProperty</code>，Proxy可以代理整个对象，而不是像defineProperty只能代理对象的属性。这使得Vue3可以更好地处理数组、Map、Set等数据类型的响应式。</p>
</li>
<li><p>vue2与vue3的区别</p>
<ol>
<li><p>在<code>vue2</code>中如果一个对象有很多属性，每个属性都会被遍历一次来进行响应式处理，这样会带来性能上的开销，而在<code>vue3</code>中采用了懒处理的方式，只有当数据被访问时才会进行响应式处理。这样可以避免不必要的响应式处理，提高性能。</p>
</li>
<li><p>在<code>vue2</code>中对数组的响应式处理是通过重写数组的变异方法来实现的，如push、pop、splice等。当使用这些方法来修改数组时，Vue会触发响应式更新。但是，当使用非变异方法如filter、slice等来处理数组时，<code>Vue2</code>并不能感知到这些操作，也无法触发响应式更新。在<code>vue3</code>中代理的是整个对象，能感知到数组所有的变化。（非变异方法虽然不会直接改变数组元素，但是其返回的如果是响应式数据如</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">&quot;item in arr.filter(item =&gt; item.name === &#x27;abc&#x27;)&quot;</span>&gt;</span>&#123;&#123; item.name &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>当filter返回值发生变化时就会触发响应式更新。</p>
</li>
<li><p><code>Vue3</code>会缓存已经处理过的数据，避免重复处理。</p>
</li>
<li><p><code>Vue3</code>在更新时采用了追踪依赖的方式，只有当数据发生改变时才会更新相关的组件。（Reactive Effect）</p>
</li>
</ol>
<blockquote>
<p>具体来说，当我们使用reactive函数或ref函数将一个对象或值转换为响应式数据后，其内部会创建一个依赖项收集器（Dep），该依赖项收集器会在Reactive Effect执行期间自动收集Reactive Effect所依赖的响应式数据，并将其存储为依赖项。</p>
<p>当响应式数据发生变化时，依赖项收集器会遍历所有依赖项，并执行它们的回调函数，从而触发更新。这个过程中，Vue3使用了Proxy对象来拦截对于数据的访问，从而实现了对于所有数据的跟踪依赖，并且避免了Vue2中重写对象属性setter方法的一些限制。</p>
</blockquote>
</li>
</ol>
</li>
</ol>
</li>
<li><h4 id="vue组件间通信"><a href="#vue组件间通信" class="headerlink" title="vue组件间通信"></a>vue组件间通信</h4><ol>
<li>父子组件通信：父组件通过props向子组件传递数据，子组件通过$emit触发事件向父组件传递数据。</li>
<li>子父组件通信：子组件通过$emit触发事件向父组件传递数据，父组件通过v-on监听子组件事件并处理数据。</li>
<li>兄弟组件通信：通过父组件作为中介，将数据传递给兄弟组件。父组件通过props向子组件传递数据，子组件通过$emit触发事件向父组件传递数据，然后父组件再通过props将数据传递给另一个子组件。</li>
<li>使用Vue的事件总线（Event Bus）来传递数据，即创建一个Vue实例作为中央事件总线，任意组件都可以通过该实例$emit触发事件和$on监听事件。</li>
<li>Vuex状态管理：使用Vuex来进行状态管理，将需要共享的数据存储在Vuex的store中，在组件中通过this.$store访问store中的数据和方法。</li>
<li>使用$refs访问组件实例：可以通过在父组件中使用ref属性来访问子组件实例，从而调用子组件中的方法或访问数据。</li>
</ol>
</li>
<li><h4 id="vuex"><a href="#vuex" class="headerlink" title="vuex"></a>vuex</h4><ol>
<li>核心概念：<ol>
<li>State: 应用程序的状态，即数据源。</li>
<li>Mutations: 修改状态的方法，以保证状态的可控性和可维护性。</li>
<li>Actions: 处理异步操作和复杂逻辑的方法，可以调用Mutations。</li>
<li>Getters: 从状态中派生出新的状态，以便在组件中使用。</li>
<li>Module：将应用程序的状态划分为多个子模块，每个子模块都有自己的State、Mutations、Actions、Getters等属性，可以更好地组织和管理应用程序的状态。</li>
</ol>
</li>
<li>使用流程<ol>
<li>定义State，定义Mutations来改变State。</li>
<li>在组件中引入State，通过计算属性或者方法获取State中的数据。</li>
<li>在组件中触发Mutations方法来修改State。</li>
<li>在需要异步操作的情况下，可以通过Actions来处理异步操作，然后调用Mutations来修改State。</li>
</ol>
</li>
<li>优点：<ol>
<li>集中管理应用程序的状态，方便调试和维护。</li>
<li>可以实现状态共享和数据共享，让组件之间的交互更加友好。</li>
<li>可以处理异步操作和复杂的逻辑，使代码更加清晰简洁。</li>
<li>通过插件机制，可以扩展Vuex的功能。</li>
</ol>
</li>
</ol>
</li>
<li><h4 id="父组件里面有子组件他是怎么渲染挂载编译的"><a href="#父组件里面有子组件他是怎么渲染挂载编译的" class="headerlink" title="父组件里面有子组件他是怎么渲染挂载编译的"></a>父组件里面有子组件他是怎么渲染挂载编译的</h4><ol>
<li>解析模板：Vue首先解析模板，将其转换为虚拟DOM树，这个过程中会识别出父组件和子组件。</li>
<li>创建父组件实例：Vue会创建父组件实例，包括状态、计算属性、方法等内容。</li>
<li>创建子组件实例：当父组件渲染到子组件时，Vue会创建子组件实例，包括状态、计算属性、方法等内容。</li>
<li>挂载子组件：Vue会将子组件挂载到父组件的DOM树上，这个过程中会执行子组件的生命周期钩子函数。</li>
<li>编译子组件模板：Vue会编译子组件的模板，将其转换为虚拟DOM树。</li>
<li>创建子组件的子节点：Vue会根据子组件的虚拟DOM树创建子组件的子节点，包括状态、计算属性、方法等内容。</li>
<li>挂载子组件的子节点：Vue会将子组件的子节点挂载到子组件的DOM树上，这个过程中会执行子组件的生命周期钩子函数。</li>
</ol>
</li>
</ol>
<h4 id="上次中通服面试回答有问题的地方"><a href="#上次中通服面试回答有问题的地方" class="headerlink" title="上次中通服面试回答有问题的地方"></a>上次中通服面试回答有问题的地方</h4><ol>
<li><p>vue路由跳转方式</p>
<ol>
<li><code>&lt;router-link to=&quot;/home&quot;&gt;Home&lt;/router-link&gt;</code></li>
<li><code>this.$router.push(&#39;/home&#39;);</code></li>
</ol>
</li>
<li><p>es6</p>
<ol>
<li><p>let和const声明变量和常量。</p>
</li>
<li><p>箭头函数，提供了更简单的函数定义方式。</p>
</li>
<li><p>模板字符串，可以轻松拼接字符串。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> name = <span class="string">&#x27;张三&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> message = <span class="string">`欢迎来到我的博客，<span class="subst">$&#123;name&#125;</span>！`</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>解构赋值，可以方便地从数组或对象中提取数据。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [a, b, c] = arr;<span class="comment">// 从数组中提取数据</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">name</span>: <span class="string">&#x27;张三&#x27;</span>, <span class="attr">age</span>: <span class="number">18</span>, <span class="attr">address</span>: &#123; <span class="attr">city</span>: <span class="string">&#x27;北京&#x27;</span>, <span class="attr">district</span>: <span class="string">&#x27;海淀区&#x27;</span> &#125; &#125;;</span><br><span class="line"><span class="keyword">const</span> &#123; name, age &#125; = obj;<span class="comment">// 从对象中提取数据</span></span><br><span class="line"><span class="keyword">const</span> &#123; name, age, <span class="attr">address</span>: &#123; city, district &#125; &#125; = obj;<span class="comment">// 嵌套解构赋值</span></span><br><span class="line"><span class="keyword">const</span> [a, b, c = <span class="number">3</span>] = arr;<span class="comment">// 设置默认值</span></span><br><span class="line"><span class="keyword">let</span> x = <span class="number">1</span>, y = <span class="number">2</span>;</span><br><span class="line">[x, y] = [y, x];<span class="comment">// 交换变量的值</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>默认参数，可以为函数参数指定默认值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">greet</span>(<span class="params">name = <span class="string">&#x27;张三&#x27;</span>, message = <span class="string">&#x27;欢迎来到我的博客！&#x27;</span></span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>类和继承，让JavaScript更像面向对象编程语言。</p>
</li>
<li><p>Promise，提供了更简单的异步编程方式。</p>
</li>
<li><p>模块化，让JavaScript可以像其他语言一样进行模块化开发。</p>
</li>
<li><p>箭头函数，提供了更简单的函数定义方式。</p>
</li>
<li><p>Generator，可以生成迭代器函数，使得异步编程更容易实现。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">myGenerator</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> iterator = <span class="title function_">myGenerator</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iterator.<span class="title function_">next</span>()); <span class="comment">// 输出 &#123; value: 1, done: false &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iterator.<span class="title function_">next</span>()); <span class="comment">// 输出 &#123; value: 2, done: false &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iterator.<span class="title function_">next</span>()); <span class="comment">// 输出 &#123; value: 3, done: false &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iterator.<span class="title function_">next</span>()); <span class="comment">// 输出 &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>for…of循环，用于遍历数组、字符串等可迭代对象。</p>
</li>
<li><p>Map和Set，weakmap，weakset，提供了更方便的数据结构。</p>
</li>
<li><p>…（展开操作符）和…（剩余操作符），可以方便地操作数组和对象。（剩余操作符：将一个函数的参数列表转换成一个数组如<code>function sum(...args)</code>）</p>
</li>
<li><p>Symbol，提供了一种新的数据类型，用于定义唯一的属性名。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//========保证属性名的唯一性</span></span><br><span class="line"><span class="keyword">const</span> mySymbol = <span class="title class_">Symbol</span>(<span class="string">&#x27;mySymbol&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line">obj[mySymbol] = <span class="string">&#x27;Hello World&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj[mySymbol]); <span class="comment">// 输出 &quot;Hello World&quot;</span></span><br><span class="line"><span class="comment">//========访问迭代器</span></span><br><span class="line"><span class="keyword">const</span> myArray = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">const</span> iterator = myArray[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iterator.<span class="title function_">next</span>()); <span class="comment">// 输出 &#123; value: 1, done: false &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iterator.<span class="title function_">next</span>()); <span class="comment">// 输出 &#123; value: 2, done: false &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iterator.<span class="title function_">next</span>()); <span class="comment">// 输出 &#123; value: 3, done: false &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iterator.<span class="title function_">next</span>()); <span class="comment">// 输出 &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>promise.race与promise.any</p>
</li>
<li><p>router与route的区别</p>
<ol>
<li>this.$router是路由器实例，提供了路由的各种方法和属性，用于进行路由的跳转和配置等操作；</li>
<li>this.$route是当前路由对应的路由信息对象，包含了当前路由的各种信息，用于获取和处理当前路由的信息。</li>
</ol>
</li>
<li><p>vue生命周期</p>
</li>
<li><p>dom事件流</p>
<ol>
<li><p>捕获阶段（Capture Phase）：事件从最外层的父元素向下传递到目标元素。在捕获阶段中，事件会从 window 对象开始向下传递，经过所有祖先元素，直到到达目标元素。</p>
</li>
<li><p>目标阶段（Target Phase）：事件到达目标元素。在目标阶段中，事件会触发目标元素的事件处理函数。</p>
</li>
<li><p>冒泡阶段（Bubbling Phase）：事件从目标元素向上传递到最外层的父元素。在冒泡阶段中，事件会从目标元素开始向上冒泡，经过所有祖先元素，直到到达 window 对象。</p>
</li>
<li><p>可以使用 <code>addEventListener</code> 方法注册事件处理函数，并通过第三个参数指定事件是否在捕获阶段或冒泡阶段处理：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> div = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line">div.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;clicked&#x27;</span>);</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>weakmap与map相关</p>
<ol>
<li>WeakMap只接受对象作为键，而且键是弱引用的，意味着当键对象被垃圾回收时，对应的键值对会自动从WeakMap中删除。</li>
<li>Map可以接受任何类型的值作为键，而且键是强引用的，即使键对象没有被使用，对应的键值对也不会被自动删除。</li>
<li>区别：<ol>
<li>引用方式：Map是可遍历的，可以使用forEach方法遍历其中的键值对，也可以使用size属性获取Map中键值对的数量。相比之下，WeakMap不支持forEach方法和size属性，也不能遍历其中的键值对。</li>
<li>Map是可遍历的，可以使用forEach方法遍历其中的键值对，也可以使用size属性获取Map中键值对的数量。相比之下，WeakMap不支持forEach方法和size属性，也不能遍历其中的键值对。（因为WeakMap中的键&#x2F;值对任何时候都可能被销毁，所以没必要提供迭代其键&#x2F;值对的能力。当然，也用不着像clear()这样一次性销毁所有键&#x2F;值的方法。）</li>
</ol>
</li>
</ol>
</li>
<li><p>weakset与set</p>
<ol>
<li><p>WeakSet 是 ES6 新增的一种集合类型，它类似于 Set，但有一些特别的地方。WeakSet 中的元素必须是对象类型，而且这些对象都是弱引用，即如果某个对象不再被其他对象引用，它就会被垃圾回收器回收，这也就意味着 WeakSet 中存储的对象可能会在任何时候被自动删除。</p>
<ol>
<li>与 Set 不同的是，WeakSet 没有 size 属性、没有 forEach 、keys 、values 、entries 等方法，也不能遍历其中的元素。WeakSet 只有 add 、delete 和 has 方法。</li>
<li>WeakSet 的主要作用是用来存储一些临时对象，例如缓存、事件监听器等，这些对象可能会在任何时候被自动删除，所以使用 WeakSet 可以避免内存泄漏的问题。</li>
</ol>
</li>
<li><p>在 JavaScript 中，Set 是一种集合类型，用于存储唯一的值，即不允许出现重复的值。Set 中可以存储任何类型的数据，包括原始类型和对象类型。Set 中的元素是按插入顺序排序的，因此可以通过 Set 的迭代器来获取元素。</p>
<ol>
<li>Set 中的元素是唯一的，不允许出现重复的值。</li>
<li>Set 中的元素是按插入顺序排序的。</li>
<li>Set 可以存储任何类型的数据，包括原始类型和对象类型。</li>
<li>Set 可以用来去重。</li>
<li>Set 中的元素是不可变的，但可以添加或删除元素。</li>
<li>Set 的值可以被迭代。</li>
<li>Set 有 size 属性，可以获取 Set 中元素的数量。</li>
</ol>
<p>Set 的常用方法包括：</p>
<ul>
<li><code>add(value)</code>：向 Set 中添加一个元素。如果该元素已经存在于 Set 中，则不会重复添加，返回 Set 对象本身。</li>
<li><code>clear()</code>：清空 Set 中的所有元素。</li>
<li><code>delete(value)</code>：从 Set 中删除一个元素。如果删除成功，则返回 true；否则返回 false。</li>
<li><code>entries()</code>：返回一个包含 Set 中所有元素的键值对的迭代器。</li>
<li><code>forEach(callbackFn[, thisArg])</code>：对 Set 中的所有元素执行指定的回调函数。可以通过可选的 thisArg 参数来指定回调函数中 this 的值。</li>
<li><code>has(value)</code>：判断 Set 中是否包含某个元素。如果包含，则返回 true；否则返回 false。</li>
<li><code>keys()</code>：返回一个包含 Set 中所有元素的键的迭代器。</li>
<li><code>size</code>：获取 Set 中元素的数量。</li>
<li><code>values()</code>：返回一个包含 Set 中所有元素的值的迭代器。</li>
</ul>
</li>
</ol>
</li>
<li><p>垃圾回收机制：</p>
<ol>
<li>引用计数算法：通过维护每个对象的引用技术来判断哪些对象需要被回收，但无法处理循环引用的情况：<ol>
<li>当一个对象被创建时，引用计数为1。</li>
<li>当有其他对象引用它时，其引用计数加1</li>
<li>当引用该对象的对象被回收时，其引用计数减1</li>
<li>当引用计数为0时，该对象就可以被回收了。</li>
</ol>
</li>
<li>标记清除法：通过标记所有活动对象，然后清除所有未被标记的垃圾对象来回收内存空间，缺点是需要遍历所有活动对象，可能会导致性能问题<ol>
<li>标记阶段：从根节点开始，遍历所有的可达对象，并将其标记为活动对象。根节点可以是全局变量、函数的局部变量、当前执行上下文中的变量等。任何一个活动对象都可以作为根节点。标记方法可以采用深度优先搜索或广度优先搜索等算法。</li>
<li>清除所有未被标记的垃圾对象，回收它们所占用的内存空间。由于标记清除算法只回收垃圾对象，因此不需要遍历所有的对象，只需要遍历所有的活动对象即可。</li>
</ol>
</li>
</ol>
</li>
</ol>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2023-03-13T01:35:06.000Z" title="2023/3/13 上午9:35:06">2023-03-13</time>发表</span><span class="level-item"><time dateTime="2023-03-15T10:39:09.641Z" title="2023/3/15 下午6:39:09">2023-03-15</time>更新</span><span class="level-item">14 分钟读完 (大约2036个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/03/13/2023-3-13%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/">2023-3-13学习记录</a></h1><div class="content"><h4 id="说一说cookie-sessionStorage-localStorage-区别？"><a href="#说一说cookie-sessionStorage-localStorage-区别？" class="headerlink" title="说一说cookie sessionStorage localStorage 区别？"></a>说一说cookie sessionStorage localStorage 区别？</h4><p>答：</p>
<p>共同点：</p>
<ol>
<li>都是在浏览器本地存储</li>
<li>都遵循同源原则，但sessionStorage限制在同一个页面</li>
</ol>
<p>区别：</p>
<ol>
<li>cookie是由服务器写入其余的都是由前端写入</li>
<li>cookie的生命周期是在服务器写入时就设定好的；LocalStorage是写入就一直存在（除非手动清除）；SessionStorage是在页面关闭时清除</li>
<li>cookie存储空间大概4kb左右，其余两个大概是5M</li>
<li>前端发请求时会自动携带Cookie，其余两个不会</li>
<li>cookie一般用于存储登录验证信息，LocalStorage存储不易变动的数据，sessionStorage可以用于检测用户是否刷新进入页面</li>
</ol>
<h4 id="JS数据类型有哪些-区别是什么？"><a href="#JS数据类型有哪些-区别是什么？" class="headerlink" title="JS数据类型有哪些,区别是什么？"></a>JS数据类型有哪些,区别是什么？</h4><p>Number、String、Boolean、Symbol、undefined、null、Object、BigInt</p>
<p>简单数据类型：Number、String、Boolean、BigInt、Symbol、null、undefined</p>
<p>复杂数据类型：Object</p>
<p>简单数据类型的存储位置在栈</p>
<p>复杂数据类型的变量与地址的对应关系存储在栈，具体的数据存储在堆</p>
<p>Symbol的特点是没有重复数据，可以作为object的key</p>
<p>Symbol的构造函数不完整，不能用<code>new Symbol()</code></p>
<p>使用<code>Object.getOwnPropotypeSymbol(symbol)</code>获取<code>key</code>数组,并使用<code>obj[key[i]]</code>遍历</p>
<p>BigInt不能与number进行计算</p>
<p>Object.getOwnPropertySymbols</p>
<h4 id="闭包的理解？"><a href="#闭包的理解？" class="headerlink" title="闭包的理解？"></a>闭包的理解？</h4><p>闭包形成的原理：作用域链，当前作用域可以访问上级作用域中的变量 闭包解决的问题：能够让函数作用域中的变量在函数执行结束之后不被销毁，同时也能在函数外部可以访问函数内部的局部变量。 闭包带来的问题：由于垃圾回收器不会将闭包中变量销毁，于是就造成了内存泄露，内存泄露积累多了就容易导致内存溢出。 加分回答 闭包的应用，能够模仿块级作用域，能够实现柯里化，在构造函数中定义特权方法、Vue中数据响应式Observer中使用闭包等。</p>
<h4 id="说一说promise是什么与使用方法？"><a href="#说一说promise是什么与使用方法？" class="headerlink" title="说一说promise是什么与使用方法？"></a>说一说promise是什么与使用方法？</h4><p>作用：Promise 是异步微任务，解决了异步多层嵌套回调的问题，让代码的可读性更高，更容易维护。</p>
<p><strong>Promise 的使用：</strong></p>
<ul>
<li>Promise 是 ES6 提供的一个构造函数，可以使用 Promise 构造函数 new 一个实例。</li>
<li>Promise 构造函数接收一个函数作为参数，这个函数有两个参数，分别是两个函数<code>resolve</code>和<code>reject</code><ul>
<li><code>resolve</code> 将 Promise 的状态由等待变为成功，将异步操作的结果作为参数传递过去。</li>
<li><code>reject</code> 则将状态由等待转变为失败，在异步操作失败时调用，将异步操作报出的错误作为参数传递过去。</li>
</ul>
</li>
<li>实例创建完成后，可以使用 <code>then</code>和<code>catch</code> 方法分别指定成功或失败的回调函数。</li>
<li>then 和 catch 最终返回的也是一个 Promise，所以可以链式调用。</li>
</ul>
<p><strong>Promise 的特点：</strong></p>
<ol>
<li>对象的状态不受外界影响（Promise 对象代表一个异步操作，有三种状态）：<ul>
<li>pending（执行中）</li>
<li>Resolved（成功，又称 Fulfilled）</li>
<li>rejected（拒绝） 其中 pending 为初始状态，fulfilled 和 rejected 为结束状态（结束状态表示 promise 的生命周期已结束）。</li>
</ul>
</li>
<li>一旦状态改变，就不会再变。任何时候都可以得到这个结果。Promise 对象的状态改变只有两种可能（状态凝固了就不会再变了）：<ul>
<li>从 Pending 变为 Resolved</li>
<li>从 Pending 变为 Rejected</li>
</ul>
</li>
<li>resolve 方法的参数是 then 中回调函数的参数；reject 方法中的参数是 catch 中的参数。</li>
<li>then 方法和 catch 方法只要不报错返回都是一个 fulfilled 状态的 promise。</li>
</ol>
<p><strong>Promise 的其他方法</strong></p>
<ul>
<li>Promise.resolve()：返回一个状态为 fulfilled 的 Promise 对象，并且将该 value 传递给对应的 then 方法。</li>
<li>Promise.reject()：返回一个状态为失败的 Promise 对象，并将给定失败信息传递给对应处理方法。</li>
<li>Promise.all()：返回一个新 promise 对象，在所有 promise 都成功时才触发成功；一旦有任何一个 promise 失败则立即触发该 promise 失败。</li>
<li>Promise.any()：接收一个 promise 集合；当其中任意一个 promise 成功，则返回那个成功值。</li>
<li>Promise.race()：当任意子promise被成功或失败后，则父promise马上也会用子promise成功返回值或失败详情作为参数调用父promise绑定相应句柄并返回该promise对象。</li>
</ul>
<h4 id="说一说跨域是什么？如何解决跨域问题？"><a href="#说一说跨域是什么？如何解决跨域问题？" class="headerlink" title="说一说跨域是什么？如何解决跨域问题？"></a>说一说跨域是什么？如何解决跨域问题？</h4><p>定义：当前页面中的某个接口请求的地址和当前页面的地址如果协议、域名、端口其中有一项不同，就说该接口跨域了。</p>
<p>跨域限制的原因：浏览器为了保证网页的安全，出的同源协议策略。</p>
<p>跨域解决方案</p>
<p><strong>cors</strong>：目前最常用的一种解决办法，通过设置后端允许跨域实现。</p>
<ul>
<li>res.setHeader(‘Access-Control-Allow-Origin’, ‘*’);</li>
<li>res.setHeader(“Access-Control-Allow-Methods”, “GET, PUT, OPTIONS, POST”);</li>
</ul>
<p><strong>node中间件、nginx反向代理</strong>：跨域限制的时候浏览器不能跨域访问服务器，node中间件和nginx反向代理，都是让请求发给代理服务器，静态页面面和代理服务器是同源的，然后代理服务器再向后端服务器发请求，服务器和服务器之间不存在同源限制。</p>
<p><strong>JSONP</strong>：利用的原理是script标签可以跨域请求资源，将回调函数作为参数拼接在url中。后端收到请求，调用该回调函数，并将数据作为参数返回去，注意设置响应头返回文档类型，应该设置成javascript。</p>
<p><strong>postmessage</strong>：H5新增API，通过发送和接收API实现跨域通信</p>
<h4 id="说一说BFC"><a href="#说一说BFC" class="headerlink" title="说一说BFC"></a>说一说BFC</h4><p>是Web页面一块独立的渲染区域，内部元素的渲染不会影响边界以外的元素。</p>
<p><strong>布局规则</strong>：内部盒子会在垂直方向，一个接一个地放置；Box垂直方向的距离由margin决定，属于同一个BFC的两个相邻Box的margin会发生重叠；每个盒子（块盒与行盒）的margin box的左边，与包含块border box的左边相接触；BFC的区域不会与float box重叠；BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素；计算BFC高度时，浮动元素也参与计算</p>
<p>形成BFC条件包括：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attribute">float</span><span class="selector-pseudo">:left</span>/<span class="attribute">right</span>;</span><br><span class="line">	<span class="attribute">position</span>:absolute/fixed;</span><br><span class="line">    <span class="attribute">overflow</span>:auto/scroll/hidden;</span><br><span class="line">    <span class="attribute">display</span>:flex/inline-block;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于清除浮动，虽然 BFC 的方式都能清除浮动，但常使用只有 <code>overflow:hidden</code>. 原因是使用 float 或 position 方式清除浮动虽然父级盒子内部浮动被清除了但父级本身又脱离文档流了会对父级后面兄弟盒子布局造成影响。如果设置父级为 display:flex 内部浮动就失效所以通常只用 overflow: hidden 清除浮动。</p>
<blockquote>
<p>除了 BFC 外还有 IFC（内联格式上下文）、GFC（网格布局格式化上下文）和 FFC（自适应格式上下文）。IFC 的高度由其包含行内元素中最高实际高度计算而来。当为一个元素设置 display 值为 grid 时，此元素将获得 GFC 独立渲染区域。display 值为 flex 或 inline-flex 的元素将生成 FFC 自适应容器。</p>
</blockquote>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2023-03-09T03:00:41.000Z" title="2023/3/9 上午11:00:41">2023-03-09</time>发表</span><span class="level-item"><time dateTime="2023-03-09T09:45:56.077Z" title="2023/3/9 下午5:45:56">2023-03-09</time>更新</span><span class="level-item">8 分钟读完 (大约1204个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/03/09/2023-3-9%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/">2023/3/9学习记录</a></h1><div class="content"><h3 id="牛客刷题"><a href="#牛客刷题" class="headerlink" title="牛客刷题"></a>牛客刷题</h3><h4 id="js单选"><a href="#js单选" class="headerlink" title="js单选"></a>js单选</h4><h5 id="require查找顺序"><a href="#require查找顺序" class="headerlink" title="require查找顺序"></a>require查找顺序</h5><p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/questionTerminal/d2da16766fe6496b8d4e06045de216d0">在文件&#x2F;home&#x2F;somebody&#x2F;workspace&#x2F;so_阿里巴巴笔试题_牛客网 (nowcoder.com)</a></p>
<ol>
<li>当前目录查找package.json，通过JSON.parse()解析，从中取出main指定的文件进行定位</li>
<li>如果main属性指定的文件名错误，或没有package.json，node会查找index.js、index.node、index.json</li>
<li>如果没找到，则搜索node_modules目录下通过npm下载的第三方模块</li>
<li>没找到抛出异常</li>
</ol>
<h6 id="js内置对象"><a href="#js内置对象" class="headerlink" title="js内置对象"></a>js内置对象</h6><p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/questionTerminal/63bc9543a21b43d59c45684bffb7c014">下列不属于JavaScript内置对象的是__牛客网 (nowcoder.com)</a></p>
<img src="https://uploadfiles.nowcoder.com/images/20170106/994851_1483692460207_900B631B37CC71E17DB04673780996DE" alt="image-20230309125044188" style="zoom: 67%;" />



<h5 id="XMLHttpRequest对象"><a href="#XMLHttpRequest对象" class="headerlink" title="XMLHttpRequest对象"></a>XMLHttpRequest对象</h5><p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/questionTerminal/e4fd0adbcbfa487aa190572e046d8257">XMLHttpRequest对象在调用send()前需要调用__牛客网 (nowcoder.com)</a></p>
<p>链接：<a target="_blank" rel="noopener" href="https://www.nowcoder.com/questionTerminal/e4fd0adbcbfa487aa190572e046d8257">https://www.nowcoder.com/questionTerminal/e4fd0adbcbfa487aa190572e046d8257</a>?<br>来源：牛客网</p>
<p>Ajax技术核心就是XMLHttpRequest对象。</p>
<p>  Ajax技术的工作原理：可以分成3步 </p>
<p>  1.创建Ajax对象：<code>var xhr = new XMLHttpRequest(); </code></p>
<p>  2.xhr 发送请求：<code>xhr.open(&#39;get&#39;,&#39;test.html&#39;,&#39;true&#39;); </code></p>
<p>​               <code>xhr.send(); </code></p>
<p>  3.xhr获取响应： </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">xhr.<span class="property">onreadystatechange</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123; </span><br><span class="line">            <span class="keyword">if</span>(xhr.<span class="property">readystate</span> ==  <span class="number">4</span>)&#123;<span class="comment">//请求的状态码 </span></span><br><span class="line">             <span class="comment">/* </span></span><br><span class="line"><span class="comment">                0:请求还没有建立（open执行前） </span></span><br><span class="line"><span class="comment">                1：请求建立了还没发送（执行了open） </span></span><br><span class="line"><span class="comment">                2：请求正式发送（执行了send） </span></span><br><span class="line"><span class="comment">                3：请求已受理，有部分数据可以用，但还没有处理完成 </span></span><br><span class="line"><span class="comment">                4：请求完全处理完成 </span></span><br><span class="line"><span class="comment">             */</span> </span><br><span class="line">              	<span class="title function_">alert</span>(xhr.<span class="property">responseText</span>);<span class="comment">//返回的数据 </span></span><br><span class="line">            &#125; </span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h5 id="标签模板"><a href="#标签模板" class="headerlink" title="标签模板"></a>标签模板</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getPersonInfo</span> (one, two, three) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(one)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(two)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(three)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> person = <span class="string">&#x27;Lydia&#x27;</span></span><br><span class="line"><span class="keyword">const</span> age = <span class="number">21</span></span><br><span class="line">getPersonInfo <span class="string">`<span class="subst">$&#123;person&#125;</span> is <span class="subst">$&#123;age&#125;</span> years old`</span></span><br></pre></td></tr></table></figure>

<h5 id="Promise-all-与Promise-race"><a href="#Promise-all-与Promise-race" class="headerlink" title="Promise.all()与Promise.race"></a>Promise.all()与Promise.race</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="title function_">all</span>([]).<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;all&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">race</span>([]).<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;race&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Promise.all 会立即返回 resolved 状态，因而会立马输出，而 Promise.race 则一直处于 pending 状态，不会走到 then ，所以永远不会输出</p>
</blockquote>
<h5 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h5><ul>
<li>箭头函数没有自己的this，而是会继承上层作用域的this，就像其他普通的变量一样</li>
<li>箭头函数不支持动态改变this值，所以不可以通过.call()、.apply()、.bind()方法来重新绑定它的this值</li>
<li>箭头函数没有arguments对象</li>
<li>过度追求箭头函数的“单行代码”写法可能会降低代码可读性</li>
<li>箭头函数虽然表面上看是匿名的，但它可以根据前面的变量名和属性名自动推断出同名的name属性</li>
<li>箭头函数不可以被new，也不会像普通函数一样自动拥有prototype属性</li>
</ul>
<h5 id="addEventListener-event-string-function-useCapture"><a href="#addEventListener-event-string-function-useCapture" class="headerlink" title="addEventListener(event:string,function,useCapture)"></a><code>addEventListener(event:string,function,useCapture)</code></h5><p>useCapture:</p>
<ul>
<li>true - 事件句柄在捕获阶段执行</li>
<li>false- false- 默认。事件句柄在冒泡阶段执行</li>
</ul>
<h5 id="将A元素拖拽并放置到B元素中，B元素需要做哪项操作"><a href="#将A元素拖拽并放置到B元素中，B元素需要做哪项操作" class="headerlink" title="将A元素拖拽并放置到B元素中，B元素需要做哪项操作"></a>将A元素拖拽并放置到B元素中，B元素需要做哪项操作</h5><blockquote>
<p>event.preventDefault()用于阻止浏览器的默认行为，防止在拖拽过程中因为拖拽，浏览器所产生的页面跳转等不被希望的行为</p>
</blockquote>
<h5 id="lt-input-type-quot-text-quot-gt-change-事件和input事件描述最准确的是？"><a href="#lt-input-type-quot-text-quot-gt-change-事件和input事件描述最准确的是？" class="headerlink" title="&lt;input type=&quot;text&quot; /&gt; change 事件和input事件描述最准确的是？"></a><code>&lt;input type=&quot;text&quot; /&gt; </code>change 事件和input事件描述最准确的是？</h5><blockquote>
<p>用户键入内容改变时，触发input事件，且在当标签失焦后，触发change事件</p>
<p>change事件在input失去焦点才会考虑触发，它的缺点是无法实时响应</p>
</blockquote>
<h5 id="lt-a-gt-标签常用rel属性"><a href="#lt-a-gt-标签常用rel属性" class="headerlink" title="&lt;a&gt;标签常用rel属性"></a><code>&lt;a&gt;</code>标签常用rel属性</h5><blockquote>
<p>a标签常用rel属性：</p>
<p><code>rel=’external’</code><br>        此属性的意思是告诉搜索引擎，这个链接不是本站链接，其实作用相当于target&#x3D;‘_blank’。<br>为什么要这样写呢？因为有些网站因为是采用严格的DOCTYPE声名的，如果你在网页源码中的第一行看到：在这种情况下target&#x3D;”_blank”会失效，因此采用rel&#x3D;’external’这个参数来替代。</p>
<p><code>rel=’nofllow’</code><br>        它是告诉搜索引擎，不要将该链接计入权重。因此多数情况下，我们可以将一些不想传递权重的链接进行nofllow处理；例如一些非本站的链接，不想传递权重，但是又需要加在页面中的像 统计代码、备案号链接、供用户查询的链接等等。</p>
<p><code>rel=“noopener noreferrer”</code><br>        在新打开的页面（baidu）中可以通过 window.opener获取到源页面的部分控制权， 即使新打开的页面是跨域的也照样可以（例如 location 就不存在跨域问题）</p>
</blockquote>
<h3 id="Leetcode刷题"><a href="#Leetcode刷题" class="headerlink" title="Leetcode刷题"></a>Leetcode刷题</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/">3. 无重复字符的最长子串 - 力扣（LeetCode）</a></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">s</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> lengthOfLongestSubstring = <span class="keyword">function</span>(<span class="params">s</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> max = <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> occ = <span class="keyword">new</span> <span class="title class_">Set</span>()</span><br><span class="line">    <span class="keyword">let</span> left = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;s.<span class="property">length</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(occ.<span class="title function_">has</span>(s[i]))&#123;</span><br><span class="line">            <span class="keyword">while</span>(occ.<span class="title function_">has</span>(s[i]))&#123;</span><br><span class="line">                occ.<span class="title function_">delete</span>(s[left])</span><br><span class="line">                left++</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        max=<span class="title class_">Math</span>.<span class="title function_">max</span>(i-left+<span class="number">1</span>,max)<span class="comment">//比如left为1，i为4，arr.slice(left,i)所取得的数组长度为i-left+1</span></span><br><span class="line">        occ.<span class="title function_">add</span>(s[i])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/compare-version-numbers/">165. 比较版本号 - 力扣（LeetCode）</a></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">version1</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">version2</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> compareVersion = <span class="keyword">function</span>(<span class="params">version1, version2</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> [v_arr1,v_arr2] = [version1.<span class="title function_">split</span>(<span class="string">&#x27;.&#x27;</span>),version2.<span class="title function_">split</span>(<span class="string">&#x27;.&#x27;</span>)] </span><br><span class="line">    <span class="keyword">let</span> [v1,v2] = [v_arr1.<span class="property">length</span>,v_arr2.<span class="property">length</span>]</span><br><span class="line">    <span class="keyword">let</span> tmp1,tmp2</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;<span class="title class_">Math</span>.<span class="title function_">max</span>(v1,v2);i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;v1&amp;&amp;i&lt;v2)&#123;</span><br><span class="line">            [tmp1,tmp2] = [<span class="built_in">parseInt</span>(v_arr1[i]),<span class="built_in">parseInt</span>(v_arr2[i])] </span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i&gt;=v1)&#123;</span><br><span class="line">            [tmp1,tmp2] = [<span class="number">0</span>,<span class="built_in">parseInt</span>(v_arr2[i])]</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            [tmp1,tmp2] = [<span class="built_in">parseInt</span>(v_arr1[i]),<span class="number">0</span>]</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(tmp1&gt;tmp2)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(tmp1&lt;tmp2)&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2023-03-08T13:26:09.000Z" title="2023/3/8 下午9:26:09">2023-03-08</time>发表</span><span class="level-item"><time dateTime="2023-03-08T13:44:06.987Z" title="2023/3/8 下午9:44:06">2023-03-08</time>更新</span><span class="level-item">3 分钟读完 (大约449个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/03/08/4399%E7%AC%94%E8%AF%95/">4399笔试</a></h1><div class="content"><h3 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h3><h4 id="小程序生命周期"><a href="#小程序生命周期" class="headerlink" title="小程序生命周期"></a>小程序生命周期</h4><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_48082900/article/details/128871647">(124条消息) 小程序中的生命周期有哪些?_小程序生命周期有哪些_Her…的博客-CSDN博客</a></p>
<h5 id="应用生命周期"><a href="#应用生命周期" class="headerlink" title="应用生命周期"></a>应用生命周期</h5><p>onLoad: 监听页面加载（只会调用一次，可获取当前页面路径的参数，相当于view中的created）</p>
<p>onShow: 监听页面显示（发送请求获取数据）</p>
<p>onReady：监听页面初次渲染完成（获取页面元素，相当于view中的mounted)</p>
<p>onHide：监听页面隐藏（如底部tab栏切换到其他页面或小程序切入后台等触发）</p>
<p>onUnload：监听页面卸载（如redirectTo或navigateBack到其他页面时触发）</p>
<h5 id="页面生命周期"><a href="#页面生命周期" class="headerlink" title="页面生命周期"></a>页面生命周期</h5><p>onLoad: 监听页面加载（只会调用一次，可获取当前页面路径的参数，相当于view中的created）</p>
<p>onShow: 监听页面显示（发送请求获取数据）</p>
<p>onReady：监听页面初次渲染完成（获取页面元素，相当于view中的mounted)</p>
<p>onHide：监听页面隐藏（如底部tab栏切换到其他页面或小程序切入后台等触发）</p>
<p>onUnload：监听页面卸载（如redirectTo或navigateBack到其他页面时触发）</p>
<h4 id="子网掩码推网络地址"><a href="#子网掩码推网络地址" class="headerlink" title="子网掩码推网络地址"></a>子网掩码推网络地址</h4><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_51921447/article/details/127057912">(124条消息) 根据子网掩码算出 IP 地址 的网络号和主机号_知道子网掩码怎么算ip地址_Blue Protocol的博客-CSDN博客</a></p>
<h4 id="微前端"><a href="#微前端" class="headerlink" title="微前端"></a>微前端</h4><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/5576598993c6">微前端-最容易看懂的微前端知识 - 简书 (jianshu.com)</a></p>
<h4 id="localstrage能否取其他网站的数据（我记得之前好像取到过？？？）"><a href="#localstrage能否取其他网站的数据（我记得之前好像取到过？？？）" class="headerlink" title="localstrage能否取其他网站的数据（我记得之前好像取到过？？？）"></a>localstrage能否取其他网站的数据（我记得之前好像取到过？？？）</h4><p>不能取</p>
<h3 id="问答题"><a href="#问答题" class="headerlink" title="问答题"></a>问答题</h3><h4 id="call-apply"><a href="#call-apply" class="headerlink" title="call apply"></a>call apply</h4></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2023-03-07T13:24:34.000Z" title="2023/3/7 下午9:24:34">2023-03-07</time>发表</span><span class="level-item"><time dateTime="2023-03-08T08:01:45.419Z" title="2023/3/8 下午4:01:45">2023-03-08</time>更新</span><span class="level-item">几秒读完 (大约33个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/03/07/%E9%87%91%E8%AF%81%E7%AC%94%E8%AF%95/">金证笔试</a></h1><div class="content"><p>问答题：</p>
<p>jQuery的find ,filter,childen</p>
<p>router与route的区别</p>
<p>vue的路由map，history，hash</p>
<p>填空题</p>
<p>vue获取dom元素</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2023-03-06T08:02:31.020Z" title="2023/3/6 下午4:02:31">2023-03-06</time>发表</span><span class="level-item"><time dateTime="2023-03-06T08:03:33.348Z" title="2023/3/6 下午4:03:33">2023-03-06</time>更新</span><span class="level-item">几秒读完 (大约24个字)</span></div></div><div class="content"><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/merge-two-sorted-lists/submissions/">21. 合并两个有序链表 - 力扣（LeetCode）</a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2023-03-05T09:45:35.000Z" title="2023/3/5 下午5:45:35">2023-03-05</time>发表</span><span class="level-item"><time dateTime="2023-03-06T08:01:49.425Z" title="2023/3/6 下午4:01:49">2023-03-06</time>更新</span><span class="level-item">3 分钟读完 (大约403个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/03/05/%E7%99%BE%E5%A5%A5%E5%AE%B6%E5%BA%AD%E7%AC%94%E8%AF%95/">百奥家庭笔试</a></h1><div class="content"><blockquote>
<p>总共3道题</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/triangle/">120. 三角形最小路径和 - 力扣（LeetCode）</a></p>
<p>之前运筹学学过类似的，可以用一个数组存储每一层中所有位置最短路径数，每次迭代更新，更新到最后一层时取出最小值</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[][]</span>&#125; <span class="variable">triangle</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> minimumTotal = <span class="keyword">function</span>(<span class="params">triangle</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> tmp_arr = triangle[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">getMinLen</span>(<span class="params">pre_arr,i</span>)&#123;</span><br><span class="line">        <span class="keyword">let</span> arr = []</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j =<span class="number">0</span> ;j&lt;=i;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(j===<span class="number">0</span>)&#123;</span><br><span class="line">                arr.<span class="title function_">push</span>(<span class="built_in">parseInt</span>(pre_arr[j])+<span class="built_in">parseInt</span>(triangle[i][j]))</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(j===i)&#123;</span><br><span class="line">                arr.<span class="title function_">push</span>(<span class="built_in">parseInt</span>(pre_arr[j-<span class="number">1</span>])+<span class="built_in">parseInt</span>(triangle[i][j]))</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                arr.<span class="title function_">push</span>(<span class="title class_">Math</span>.<span class="title function_">min</span>(<span class="built_in">parseInt</span>(pre_arr[j]),</span><br><span class="line">                <span class="built_in">parseInt</span>(pre_arr[j-<span class="number">1</span>]))+<span class="built_in">parseInt</span>(triangle[i][j]))</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">1</span>;i&lt;triangle.<span class="property">length</span>;i++)&#123;</span><br><span class="line">        tmp_arr = <span class="title function_">getMinLen</span>(tmp_arr,i)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">min</span>(...tmp_arr)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>有一题是求最大对角线元素和，找了一下没找到原题，大概就是</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],</span><br><span class="line"> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],</span><br><span class="line"> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],</span><br><span class="line"> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]]<span class="comment">//只能是正数</span></span><br><span class="line"><span class="comment">//然后遍历里面的位置，找出最大的对角线和，如这题就是</span></span><br><span class="line"><span class="comment">//以此为例，以第一行为基点，选择两个点遍历从每个点出发的x</span></span><br></pre></td></tr></table></figure>

<p>求一个三角形从上往下最短路径，有个规则：第i层往下传递只能传递到i或i+1个</p>
<h4 id="cvte的笔试参考"><a href="#cvte的笔试参考" class="headerlink" title="cvte的笔试参考"></a>cvte的笔试参考</h4><p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/discuss/432595387879337984?sourceSSR=search">CVTE 前端实习生笔试_牛客网 (nowcoder.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_34629352/article/details/106186930">(121条消息) DOMContentLoaded与load的区别、触发时机_domcontentloaded和load的区别_baoleilei6的博客-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_47281635/article/details/127523248">(121条消息) 【问题】前端模块化_秦山璞的博客-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_52856519/article/details/128188074">(121条消息) CommonJS的理解_conmoojs_全栈科学家的博客-CSDN博客</a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2023-02-20T09:00:41.865Z" title="2023/2/20 下午5:00:41">2023-02-20</time>发表</span><span class="level-item"><time dateTime="2023-02-20T09:46:16.307Z" title="2023/2/20 下午5:46:16">2023-02-20</time>更新</span><span class="level-item">3 分钟读完 (大约428个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/02/20/2023-2-20%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/">2023-2-20</a></h1><div class="content"><blockquote>
<p>用<strong>两个栈</strong>实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )</p>
</blockquote>
<p>官方思路：</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/solution/mian-shi-ti-09-yong-liang-ge-zhan-shi-xian-dui-l-2/">面试题09. 用两个栈实现队列（清晰图解） - 用两个栈实现队列 - 力扣（LeetCode）</a></p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/solution/mian-shi-ti-09-yong-liang-ge-zhan-shi-xian-dui-l-3/">用两个栈实现队列 - 用两个栈实现队列 - 力扣（LeetCode）</a></p>
<p>inStack与outStack只能操作数组尾部模拟栈，inStack作为临时栈，只有在deleteHead时才会将数据转移到outStack中，outStack作为deleteHead所操作的数组。</p>
<ol>
<li>appendTail时将数据push进去</li>
<li>当deleteHead时：<ul>
<li>判断两个数组是否为空，若为空则意味着队列没有元素；</li>
<li>OutStack为空，inStack非空，队列中有元素，但全在inStack中，此时需要轮询将inStack中的全部转移到OutStack中，由于只能操作inStack尾部元素，将inStack尾部删除并元素push进outStack中，此时Stack顺序调换，删除outStack尾部元素，符合队列先进先出特征</li>
</ul>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">CQueue</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">inStack</span> = []</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">outStack</span> = []</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">value</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">void</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">CQueue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">appendTail</span> = <span class="keyword">function</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">inStack</span>.<span class="title function_">push</span>(value)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">CQueue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">deleteHead</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="variable language_">this</span>.<span class="property">outStack</span>.<span class="property">length</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="variable language_">this</span>.<span class="property">inStack</span>.<span class="property">length</span>)&#123;</span><br><span class="line">         <span class="keyword">return</span> -<span class="number">1</span>   </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(<span class="variable language_">this</span>.<span class="property">inStack</span>.<span class="property">length</span>)&#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">outStack</span>.<span class="title function_">push</span>(<span class="variable language_">this</span>.<span class="property">inStack</span>.<span class="title function_">pop</span>())</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">outStack</span>.<span class="title function_">pop</span>()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your CQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * var obj = new CQueue()</span></span><br><span class="line"><span class="comment"> * obj.appendTail(value)</span></span><br><span class="line"><span class="comment"> * var param_2 = obj.deleteHead()</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2023-02-16T00:12:52.000Z" title="2023/2/16 上午8:12:52">2023-02-16</time>发表</span><span class="level-item"><time dateTime="2023-03-06T10:51:29.317Z" title="2023/3/6 下午6:51:29">2023-03-06</time>更新</span><span class="level-item">21 分钟读完 (大约3084个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/02/16/2023-2-16%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/">2023-2-16学习记录</a></h1><div class="content"><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/7023271065392513038">牛客最新前端JS笔试百题 - 掘金 (juejin.cn)</a></p>
<blockquote>
<p>以下不属于 typeof 运算符返回值的是？</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A. <span class="string">&quot;string&quot;</span></span><br><span class="line">B. <span class="string">&quot;function&quot;</span></span><br><span class="line">C. <span class="string">&quot;object&quot;</span></span><br><span class="line">D. <span class="string">&quot;null&quot;</span></span><br></pre></td></tr></table></figure>

<p><code>typeof</code>返回值</p>
<p>‘string’        –字符串类型的变量或值</p>
<p>‘undefined’   –未定义的变量或值</p>
<p>‘boolen’       –布尔类型的变量或值</p>
<p>‘number’      –数字类型的变量或值</p>
<p>‘object’        –对象类型的变量或值，或者null,Array</p>
<p>‘function’     –函数类型的变量或值</p>
</blockquote>
<blockquote>
<p>以下关于JavaScript中数据类型的说法错误的是()</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A. 数据类型分为基本数据类型和引用数据类型</span><br><span class="line">B. <span class="title class_">JavaScript</span>一共有<span class="number">8</span>种数据类型</span><br><span class="line">C. <span class="title class_">Object</span>是引用数据类型，且只存储于堆(heap)中</span><br><span class="line">D. <span class="title class_">BigInt</span>是可以表示任意精度整数的基本数据类型，存储于栈(stack)中</span><br></pre></td></tr></table></figure>

<p>C：Object即在堆中存储数据，也在栈中存储地址及变量名</p>
</blockquote>
<blockquote>
<p>请选择结果为ture的表达式？</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A. <span class="literal">null</span> <span class="keyword">instanceof</span> <span class="title class_">Object</span></span><br><span class="line">B. <span class="literal">null</span> === <span class="literal">undefined</span></span><br><span class="line">C. <span class="literal">null</span> == <span class="literal">undefined</span></span><br><span class="line">D. <span class="title class_">NaN</span> == <span class="title class_">NaN</span></span><br></pre></td></tr></table></figure>

<p>A：null在内存里的表示就是，栈中的变量没有指向堆中的内存对象。由于null并不是由Object为原型创建出来的，因此<code>null instanceof Object</code>为false</p>
<p>C：js对于相等的判断流程：</p>
<ol>
<li>如果操作数是布尔值，则将布尔值转化为0&#x2F;1（隐式转换）</li>
<li>如果是字符串和数字，则将字符串转化为数字（隐式转换）</li>
<li>如果是Object，则会调用<code>valueOf()</code>方法</li>
</ol>
<p>但<code>null==undefined//false</code>不是隐式转换而来的，仅仅是设计者觉得它两很像</p>
</blockquote>
<blockquote>
<p>下列代码结果为 true 的是？</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A. <span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">&#x27;a&#x27;</span>) === <span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">B. <span class="title class_">Symbol</span>(<span class="string">&#x27;a&#x27;</span>) === <span class="title class_">Symbol</span>(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">C. <span class="title class_">NaN</span> === <span class="title class_">NaN</span></span><br><span class="line">D. &#123;&#125; === &#123;&#125;</span><br></pre></td></tr></table></figure>

<p><code>Symbol.for(a)</code>全局注册表中寻找描述为<code>a</code>的<code>Symbol</code>，若没有符合条件的<code>Symbol</code>，则创建一个描述为<code>a</code>的<code>Symbol</code>，若有则赋值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="title class_">Symbol</span>(<span class="string">&quot;a&quot;</span>)</span><br><span class="line"><span class="keyword">let</span> b = <span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">&quot;a&quot;</span>)</span><br><span class="line">a === b <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<ol>
<li>使用<code>Symbol(&quot;a&quot;)</code>直接创建，所以该<code>Symbol(&quot;a&quot;)</code>不在全局注册表中</li>
<li>使用<code>Symbol.for(&quot;a&quot;)</code>在全局注册表中寻找描述为<code>a</code>的<code>Symbol</code>，并没有找到，所以在全局注册表中又创建了一个描述为<code>a</code>的新的<code>Symbol</code></li>
<li>秉承<code>Symbol</code>创建的唯一特性，所以<code>a</code>与<code>b</code>创建的<code>Symbol</code>不同，结果为<code>false</code></li>
</ol>
<p><strong>Symbol</strong>(‘a’) &#x3D;&#x3D;&#x3D; <strong>Symbol</strong>(‘a’)：Symbol()返回值是唯一的</p>
</blockquote>
<blockquote>
<p>根据如下变量，下列表达式中返回值为true的是</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> b = [];</span><br><span class="line"><span class="keyword">var</span> c = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> d = <span class="literal">true</span>;</span><br><span class="line">A. (a || b) === <span class="literal">true</span></span><br><span class="line">B. (b &amp;&amp; c) === <span class="literal">true</span></span><br><span class="line">C. (c &amp;&amp; d) === <span class="literal">true</span></span><br><span class="line">D. (d || a) === <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p><code>||</code></p>
<ol>
<li>只要”||”前面为false,不管”||”后面是true还是false，都返回”||”后面的值。</li>
<li>只要”||”前面为true,不管”||”后面是true还是false，都返回”||”前面的值。</li>
</ol>
</blockquote>
<blockquote>
<p>下面代码输出为true的是?</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A. <span class="variable language_">console</span>.<span class="title function_">log</span>([] === []);</span><br><span class="line">B. <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="literal">undefined</span> == <span class="number">0</span>);</span><br><span class="line">C. <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="literal">undefined</span> == <span class="literal">false</span>);</span><br><span class="line">D. <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="literal">false</span> == <span class="string">&#x27;&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p><code>undefine</code>：undefined在进行隐式转换时转化为NaN，并进行比较操作</p>
</blockquote>
<blockquote>
<p>以下表达式，正确的是（D）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A. <span class="title class_">Number</span>(<span class="string">&#x27;a&#x27;</span>) == <span class="title class_">Number</span>(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">B. -<span class="number">1</span> == <span class="literal">true</span></span><br><span class="line">C. <span class="number">3</span> + <span class="string">&#x27;2&#x27;</span> === <span class="number">5</span></span><br><span class="line">D. ![] == <span class="string">&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<p><code>3+&#39;2&#39;===5</code>:先比较’2’&#x3D;&#x3D;&#x3D;5，再计算3+</p>
</blockquote>
<blockquote>
<p>如何把 7.25 四舍五入为最接近的整数（A）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A. <span class="title class_">Math</span>.<span class="title function_">round</span>(<span class="number">7.25</span>)</span><br><span class="line">B. <span class="title class_">Math</span>.<span class="title function_">ceil</span>(<span class="number">7.25</span>)</span><br><span class="line">C. <span class="title function_">round</span>(<span class="number">7.25</span>)</span><br><span class="line">D. <span class="title class_">Math</span>.<span class="title function_">rnd</span>(<span class="number">7.25</span>)</span><br></pre></td></tr></table></figure>

<p><code>Math.round</code>：5以上取上，5以下取下</p>
<p><code>Math.ceil</code>：向上取整</p>
<p><code>Math.floor</code>：向下取整</p>
</blockquote>
<blockquote>
<ol>
<li>String对象的哪个方法可以寻找子字符串并返回该子字符串位置 <strong>BC</strong></li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A. <span class="title function_">match</span>()<span class="comment">//正则匹配</span></span><br><span class="line">B. <span class="title function_">indexOf</span>()</span><br><span class="line">C. <span class="title function_">search</span>()</span><br><span class="line">D. <span class="title function_">concat</span>()</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<ol>
<li>下面分别使用 JSON.stringify 方法，返回值 res 分别是 <strong>C</strong></li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fn = <span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line"><span class="keyword">const</span> res = <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(fn)</span><br><span class="line"><span class="keyword">const</span> num = <span class="number">123</span></span><br><span class="line"><span class="keyword">const</span> res = <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(num)</span><br><span class="line"><span class="keyword">const</span> res = <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(<span class="title class_">NaN</span>)</span><br><span class="line"><span class="keyword">const</span> b = <span class="literal">true</span></span><br><span class="line"><span class="keyword">const</span> res = <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(b)</span><br><span class="line">A. <span class="string">&#x27;function&#x27;</span>、<span class="string">&#x27;123&#x27;</span>、<span class="string">&#x27;NaN&#x27;</span>、<span class="string">&#x27;true&#x27;</span></span><br><span class="line">B. <span class="literal">undefined</span>、<span class="string">&#x27;123&#x27;</span>、<span class="literal">undefined</span>、<span class="string">&#x27;true&#x27;</span></span><br><span class="line">C. <span class="literal">undefined</span>、<span class="string">&#x27;123&#x27;</span>、<span class="string">&#x27;null&#x27;</span>、<span class="string">&#x27;true&#x27;</span></span><br><span class="line">D. <span class="literal">undefined</span>、<span class="string">&#x27;123&#x27;</span>、<span class="string">&#x27;null&#x27;</span>、<span class="literal">undefined</span></span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/7173887952048062471">关于 JSON 数据格式的完全使用指南 - 掘金 (juejin.cn)</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/7047728813823754254">JSON.parse 和 JSON.stringify 详解 - 掘金 (juejin.cn)</a></p>
<p>函数，日期对象无法进行序列化，NaN</p>
</blockquote>
<blockquote>
<ol>
<li>js数组中不会改变原有数组的方法是(B)</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">A. push</span><br><span class="line">B. concat<span class="comment">//创建新数组，当数组中都是简单数据类型，深拷贝，当数组都是复杂数据类型，浅拷贝</span></span><br><span class="line">C. sort</span><br><span class="line">D. shift<span class="comment">//删除数组中的第一个元素，并将这个被删除的元素返回</span></span><br><span class="line"><span class="comment">//slice也不会改变原数组</span></span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>编写高性能JavaScript，以下描述错误的是（<strong>B</strong>）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A. 遵循严格模式：<span class="string">&quot;use strict&quot;</span></span><br><span class="line">B. 将js脚本放在页面顶部，加快渲染页面</span><br><span class="line">C. 将js脚本成组打包，减少请求，尽量减少使用闭包</span><br><span class="line">D. 使用非阻塞方式下载js脚本，最小化重绘(repaint)和回流(reflow)</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>有关JavaScript中系统方法的描述，错误的是？</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A. <span class="built_in">parseFloat</span>方法：该方法将一个字符串转换成对应的小数</span><br><span class="line">B. <span class="built_in">isNaN</span>方法：该方法用于检测参数是否为数值型，如果是，返回<span class="literal">true</span>，否则，返回<span class="literal">false</span>。</span><br><span class="line">C. <span class="built_in">escape</span>方法： 该方法返回对一个字符串编码后的结果字符串</span><br><span class="line">D. <span class="built_in">eval</span>方法：该方法将某个参数字符串作为一个<span class="title class_">JavaScript</span>执行题</span><br></pre></td></tr></table></figure>

<p>B说反了</p>
</blockquote>
<blockquote>
<p>下面列出的浏览器，无webkit内核的是(<strong>D</strong>)</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A. chrome</span><br><span class="line">B. <span class="title class_">Safari</span></span><br><span class="line">C. 搜狗浏览器</span><br><span class="line">D. <span class="title class_">Firefox</span></span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>在JavaScript中下面选项关于this描述正确的是（<strong>A</strong>）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A. 在使用<span class="keyword">new</span>实例化对象时, <span class="variable language_">this</span>指向这个实例对象</span><br><span class="line">B. 将对象的方法赋值给变量A。执行<span class="title function_">A</span>()时 该方法中的<span class="variable language_">this</span>指向这个对象。 </span><br><span class="line">C. 在函数定义时,<span class="variable language_">this</span>指向全局变量</span><br><span class="line">D. 在浏览器下的全局范围内，<span class="variable language_">this</span>指向全局对象</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6984188410659340324#heading-5">「硬核JS」你的程序中可能存在内存泄漏 - 掘金 (juejin.cn)</a></p>
<p>那个操作不会造成内存泄露（<strong>D</strong>）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A. 没有清理的<span class="variable constant_">DOM</span>元素引用</span><br><span class="line">B. 被遗忘的定时器</span><br><span class="line">C. 事件侦听没有移除</span><br><span class="line">D. 局部变量不用时，没有设为<span class="literal">null</span></span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>下列关于闭包理解错误的是（<strong>D</strong>）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A. 增加一定的内存消耗</span><br><span class="line">B. 使用不当可能会导致内存泄漏</span><br><span class="line">C. 可以使用闭包模拟私有方法</span><br><span class="line">D. 闭包会改动对象的原型链</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>以下关于原型链的描述正确的是:(<strong>B</strong>)</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A. 通过原型链继承的属性和对象自己定义的属性等效</span><br><span class="line">B. 通过原型链可以模拟对象的私有属性</span><br><span class="line">C. 在对象上访问不存在的属性时,会依次遍历整条原型链</span><br><span class="line">D. 所有 <span class="title class_">JavaScript</span> 中的对象都是位于原型链顶端的 <span class="string">`Object`</span> 的实例</span><br></pre></td></tr></table></figure>
</blockquote>
<p>CD D C B C</p>
<blockquote>
<p>将A元素拖拽并放置到B元素中，B元素需要做哪项操作()？</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A. event.<span class="title function_">preventDefault</span>()<span class="comment">//取消事件的默认动作。</span></span><br><span class="line">B. event.<span class="title function_">prevent</span>()</span><br><span class="line">C. event.<span class="title function_">drag</span>()<span class="comment">//鼠标正在被拖动触发</span></span><br><span class="line">D. event.<span class="title function_">drop</span>()<span class="comment">//当鼠标松开触发</span></span><br></pre></td></tr></table></figure>

<p>event.preventDefault()用于阻止浏览器的默认行为，防止在拖拽过程中因为拖拽，浏览器所产生的页面跳转等不被希望的行为</p>
</blockquote>
<blockquote>
<p>以下不支持冒泡的鼠标事件为( )？</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A. mouseover</span><br><span class="line">B. click</span><br><span class="line">C. mouseleave</span><br><span class="line">D. mousemove</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/7193364761436749879">【深入学习JavaScript系列】28、事件传播 - 掘金 (juejin.cn)</a></p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/86f3961f1d56">事件 - 简书 (jianshu.com)</a></p>
</blockquote>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/7193364761436749879">【深入学习JavaScript系列】28、事件传播 - 掘金 (juejin.cn)</a></p>
<p>事件传播的三个阶段是什么</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">目标 -&gt; 捕获 -&gt; 冒泡</span><br><span class="line">冒泡 -&gt; 目标 -&gt; 捕获</span><br><span class="line">目标 -&gt; 冒泡 -&gt; 捕获</span><br><span class="line">捕获 -&gt; 目标 -&gt; 冒泡</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>​	下面有关 javascript 常见事件的触发情况，描述错误的是？</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A. onchange：用户改变域的内容</span><br><span class="line">B. onkeypress：某个键盘的键被按下或按住</span><br><span class="line">C. onmousedown：某个鼠标按键被按下</span><br><span class="line">D. onblur：元素获得焦点</span><br></pre></td></tr></table></figure>

<p>onblur：对象失去焦点时发生</p>
</blockquote>
<blockquote>
<p>下列哪项不属于DOM查找节点的属性()？</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A. parentObj.<span class="property">firstChild</span></span><br><span class="line">B. parentObj.<span class="property">children</span></span><br><span class="line">C. neborNode.<span class="property">previousSibling</span></span><br><span class="line">D. neborNode.<span class="property">siblings</span></span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/questionTerminal/6238c92c287c482eb46e45b78c30f6e0?orderByHotValue=1&page=1">下列哪项不属于DOM查找节点的属性（）？_360笔试题_牛客网 (nowcoder.com)</a></p>
</blockquote>
<blockquote>
<p>DOM元素的以下属性改变会导致重排(reflows)的是 （<strong>C</strong>）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">outline</span><br><span class="line">visiblity</span><br><span class="line">font-size</span><br><span class="line">background-color</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904083212468238">重排(reflow)和重绘(repaint) - 掘金 (juejin.cn)</a></p>
</blockquote>
<blockquote>
<p>以下方案中，不是用于解决回调陷阱的的是：（D）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A. <span class="title class_">Promise</span></span><br><span class="line">B. <span class="title class_">Generator</span></span><br><span class="line">C. <span class="keyword">async</span></span><br><span class="line">D. <span class="title class_">Proxy</span></span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/7108187709076111367">什么是回调地狱，如何用Promise解决回调地狱，看完这篇你就明白了。 - 掘金 (juejin.cn)</a></p>
</blockquote>
<blockquote>
<p>以下属于操作符 typeof 的返回值的是：（<strong>128</strong>）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>)<span class="keyword">function</span></span><br><span class="line">(<span class="params"><span class="number">2</span></span>) object</span><br><span class="line">(<span class="number">3</span>) <span class="literal">null</span></span><br><span class="line">(<span class="number">4</span>) array</span><br><span class="line">(<span class="number">5</span>) <span class="title class_">NaN</span></span><br><span class="line">(<span class="number">6</span>) bigint</span><br><span class="line">(<span class="number">7</span>) regexp</span><br><span class="line">(<span class="number">8</span>) <span class="literal">undefined</span></span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>以下()结果等于字符串string（<strong>ABDE</strong>）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">A. <span class="keyword">typeof</span> <span class="string">&#x27;string&#x27;</span></span><br><span class="line">B. <span class="title class_">String</span>(<span class="string">&#x27;string&#x27;</span>).<span class="title function_">toString</span>()</span><br><span class="line">C. <span class="string">&#x27;string&#x27;</span>.<span class="title function_">split</span>(<span class="string">&#x27;&#x27;</span>).<span class="title function_">sort</span>().<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">D. (<span class="keyword">function</span>(<span class="params">string</span>)&#123;<span class="keyword">return</span> string&#125;)(<span class="string">&#x27;string&#x27;</span>)</span><br><span class="line">E. <span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="string">&#x27;&#123;&quot;string&quot;:&quot;string&quot;&#125;&#x27;</span>).<span class="property">string</span></span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>以下哪些选项可以将集合A转化为数组？（<strong>ABCD</strong>）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A. <span class="title class_">Array</span>.<span class="title function_">from</span>(A)</span><br><span class="line">B. [].<span class="property">slice</span>.<span class="title function_">apply</span>(A)</span><br><span class="line">C. [...A]</span><br><span class="line">D. [].<span class="property">map</span>.<span class="title function_">call</span>(A, <span class="function"><span class="params">o</span> =&gt;</span> o)</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>下列结果返回 true 的是（<strong>AC</strong>）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">A. <span class="literal">null</span> == <span class="literal">undefined</span></span><br><span class="line">B. <span class="literal">null</span> === <span class="literal">undefined</span></span><br><span class="line">C. <span class="literal">null</span> === <span class="literal">null</span></span><br><span class="line">D. <span class="title class_">NaN</span> == <span class="literal">null</span></span><br><span class="line">E. <span class="title class_">NaN</span> === <span class="title class_">NaN</span></span><br><span class="line">F. <span class="title class_">Infinity</span> + <span class="number">1</span> !== <span class="title class_">Infinity</span></span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>关于以下代码，说法正确的有哪些？ <code>function Person() &#123; &#125; var person = new Person();</code> （<strong>ACD</strong>）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A. 每一个原型都有一个constructor属性指向关联的构造函数。</span><br><span class="line">B. 每一个对象都有一个prototype属性。<span class="comment">//每一个函数对象都有一个prototype属性，但是普通对象是没有的</span></span><br><span class="line">C. <span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(person) === <span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span></span><br><span class="line">D. person.<span class="property">constructor</span> === <span class="title class_">Person</span></span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>以下关于let和const的说法中正确的是:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A. <span class="keyword">let</span>声明的变量值和类型都可以改变</span><br><span class="line">B. <span class="keyword">const</span>声明的常量不可以改变</span><br><span class="line">C. 两者都不存在变量提升，同时存在暂时性死区，只能在声明的位置后面使用</span><br><span class="line">D. <span class="keyword">const</span>可以先声明再初始化，可以后赋值<span class="comment">//必须要初始化</span></span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>下面关于Promise说法正确的是(注意“返回结果”的意思包含成功或者失败)</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A. <span class="title class_">Promise</span>.<span class="property">all</span>在所有给定的promise都fulfilled后才返回结果<span class="comment">//</span></span><br><span class="line">B. <span class="title class_">Promise</span>.<span class="property">race</span>在给定的promise中，某个fulfilled后才返回结果</span><br><span class="line">C. promise.<span class="property">then</span>的回调函数中，可以返回一个新的promise</span><br><span class="line">D. 对于一个向后台获取数据已经产生结果的<span class="attr">promise</span>:p1，再次调用p1.<span class="property">then</span>，不会去重新发起请求获取数据</span><br></pre></td></tr></table></figure>

<p>A：多个promise包装成数组，一起触发，若全部fulfilled则成功，若有一个rejected则失败，整体抛出的异常为第一个失败的promise抛出的异常。最终只返回一个Promise，若全部成功，则返回的value为一个数组，包装时内部的顺序与完成后的顺序一致。</p>
<p>B：是指，将多个promise包装成数组，一起触发，只要有一个且是第一个成功或失败则整体的结果就是这个promise的结果。该方法只返回一个Promise</p>
</blockquote>
<blockquote>
<p>下列关于使用 JS 修改元素样式的代码，正确的有哪些？（<strong>BCD</strong>）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">style</span>.[<span class="string">&#x27;background-color&#x27;</span>] = <span class="string">&#x27;#fff&#x27;</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">style</span>.<span class="title function_">setProperty</span>(<span class="string">&#x27;background-color&#x27;</span>, <span class="string">&#x27;#fff&#x27;</span>)</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">style</span> = <span class="string">&#x27;background-color: #fff&#x27;</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">style</span>.<span class="property">fontSize</span> = <span class="string">&#x27;14px&#x27;</span></span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>下列方法可用于阻止事件冒泡的有(<strong>ABD</strong>)</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A. event.<span class="property">cancelBubble</span> = <span class="literal">true</span>;</span><br><span class="line">B. event.<span class="title function_">stopPropagation</span>();</span><br><span class="line">C. event.<span class="title function_">preventDefault</span>();</span><br><span class="line">D. <span class="keyword">return</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>以下使用 typeof 操作符的代码的输出结果为</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="keyword">typeof</span> x</span><br><span class="line"><span class="keyword">var</span> res = <span class="keyword">typeof</span> <span class="keyword">typeof</span> x;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x, res)<span class="comment">//undefined string</span></span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p><code>1 + - + + + - + 1 </code>&#x3D;<code>1 + (- + + + - +) 1</code>&#x3D;<code>1+1</code></p>
<p><code>(- + + + - +)</code>为正负号</p>
</blockquote>
<blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">showCase</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="keyword">switch</span>(value) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;A&#x27;</span>:</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Case A&#x27;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;B&#x27;</span>:</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Case B&#x27;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="attr">undefined</span>:</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Case undefined&#x27;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="attr">default</span>:</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Case default&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">showCase</span>(<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&#x27;A&#x27;</span>));</span><br></pre></td></tr></table></figure>

<ul>
<li>switch 是严格比较(&#x3D;&#x3D;&#x3D;)</li>
<li>String 实例和字符串是不一样的，String实例是对象类型，而字符串是 string 类型</li>
<li>var str1&#x3D;’aa’, str2 &#x3D; new String(‘aa’)；typeof str1 &#x2F;&#x2F;‘string’。 typeof str2 &#x2F;&#x2F; ‘object’</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">showCase</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="keyword">switch</span>(value) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;A&#x27;</span>:</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Case A&#x27;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;B&#x27;</span>:</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Case B&#x27;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="attr">undefined</span>:</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Case undefined&#x27;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="attr">default</span>:</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Case default&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">showCase</span>(<span class="title class_">String</span>(<span class="string">&#x27;A&#x27;</span>));</span><br></pre></td></tr></table></figure>

<ul>
<li>String(‘A’)就是返回一个字符串</li>
</ul>
</blockquote>
<blockquote>
<p> ​	2</p>
<p> 4</p>
</blockquote>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2023-02-12T02:47:22.000Z" title="2023/2/12 上午10:47:22">2023-02-12</time>发表</span><span class="level-item"><time dateTime="2023-02-12T04:17:46.581Z" title="2023/2/12 下午12:17:46">2023-02-12</time>更新</span><span class="level-item">2 分钟读完 (大约271个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/02/12/2023-2-12%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/">2023/2/12学习记录</a></h1><div class="content"><blockquote>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/7164928163774988302">「2022」JavaScript最新高频面试题指南（上） - 掘金 (juejin.cn)</a></p>
</blockquote>
<blockquote>
<h4 id="将数组的length设置为0，取第一个元素会返回什么？"><a href="#将数组的length设置为0，取第一个元素会返回什么？" class="headerlink" title="将数组的length设置为0，取第一个元素会返回什么？"></a>将数组的length设置为0，取第一个元素会返回什么？</h4><p>设置 <code>length = 0</code> 会清空数组，所以会返回 <code>undefined</code></p>
</blockquote>
<blockquote>
<h4 id="Math-ceil和Math-floor有什么区别？"><a href="#Math-ceil和Math-floor有什么区别？" class="headerlink" title="Math.ceil和Math.floor有什么区别？"></a>Math.ceil和Math.floor有什么区别？</h4><p><code>Math.ceil()</code>： 向上取整，函数返回一个大于或等于给定数字的最小整数。</p>
<p><code>Math.floor()</code>： 向下取整，函数返回一个小于或等于给定数字的最大整数。</p>
</blockquote>
<blockquote>
<h4 id="typeof-NaN-的结果是什么？"><a href="#typeof-NaN-的结果是什么？" class="headerlink" title="typeof NaN 的结果是什么？"></a>typeof NaN 的结果是什么？</h4><p>NaN 指“不是一个数字”（not a number），NaN 是一个“警戒值”（sentinel value，有特殊用途的常规值），用于指出数字类型中的错误情况，即“执行数学运算没有成功，这是失败后返回的结果”。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="title class_">NaN</span>; <span class="comment">// &quot;number&quot;</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>NaN 是一个特殊值，它和自身不相等，是唯一一个非自反（自反，reflexive，即 x &#x3D;&#x3D;&#x3D; x 不成立）的值。而 NaN !&#x3D;&#x3D; NaN 为 true。</p>
</blockquote>
</div></article></div><nav class="pagination" role="navigation" aria-label="pagination"><div class="pagination-previous is-invisible is-hidden-mobile"><a href="/page/0/">上一页</a></div><div class="pagination-next"><a href="/page/2/">下一页</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link is-current" href="/">1</a></li><li><a class="pagination-link" href="/page/2/">2</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/imgs/avatar.jpg" alt="一条懒狗"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">一条懒狗</p><p class="is-size-6 is-block">前端小白</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>广州/珠海</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">19</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">1</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">7</p></a></div></div></nav></div></div><!--!--><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB/"><span class="level-start"><span class="level-item">学习汇总</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li></ul></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-03-21T08:36:30.000Z">2023-03-21</time></p><p class="title"><a href="/2023/03/21/2023-3-21%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/">2023-3-21学习记录</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-03-13T01:35:06.000Z">2023-03-13</time></p><p class="title"><a href="/2023/03/13/2023-3-13%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/">2023-3-13学习记录</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-03-09T03:00:41.000Z">2023-03-09</time></p><p class="title"><a href="/2023/03/09/2023-3-9%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/">2023/3/9学习记录</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-03-08T13:26:09.000Z">2023-03-08</time></p><p class="title"><a href="/2023/03/08/4399%E7%AC%94%E8%AF%95/">4399笔试</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-03-07T13:24:34.000Z">2023-03-07</time></p><p class="title"><a href="/2023/03/07/%E9%87%91%E8%AF%81%E7%AC%94%E8%AF%95/">金证笔试</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2023/03/"><span class="level-start"><span class="level-item">三月 2023</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/02/"><span class="level-start"><span class="level-item">二月 2023</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/10/"><span class="level-start"><span class="level-item">十月 2022</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/09/"><span class="level-start"><span class="level-item">九月 2022</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Css/"><span class="tag">Css</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Html/"><span class="tag">Html</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/JavaScript/"><span class="tag">JavaScript</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Sass/"><span class="tag">Sass</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Vue2/"><span class="tag">Vue2</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/leetcode-%E6%A0%88-%E9%98%9F%E5%88%97/"><span class="tag">leetcode 栈 队列</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%AC%94%E8%AF%95%E9%A2%98/"><span class="tag">笔试题</span><span class="tag">1</span></a></div></div></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/imgs/avatar.jpg" alt="一条懒狗的博客" height="28"></a><p class="is-size-7"><span>&copy; 2023 一条懒狗</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-cn");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>